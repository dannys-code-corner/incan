---
source: tests/codegen_snapshot_tests.rs
expression: rust_code
---
// Generated by the Incan compiler v<INCAN_VERSION>

#![allow(unused_imports, dead_code, unused_variables)]

// __INCAN_INSERT_MODS__

use incan_stdlib::prelude::*;
use incan_derive::{FieldInfo, IncanClass};
use std::collections::HashMap;
#[derive(Debug, Clone, PartialEq)]
enum Color {
    Red,
    Green,
    Blue,
}
impl Color {
    pub fn message(&self) -> String {
        match self {
            Self::Red => "Red".to_string(),
            Self::Green => "Green".to_string(),
            Self::Blue => "Blue".to_string(),
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
enum Maybe {
    Some(i64),
    None,
}
impl Maybe {
    pub fn message(&self) -> String {
        match self {
            Self::Some(_) => "Some".to_string(),
            Self::None => "None".to_string(),
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
enum Result {
    Ok(i64),
    Err(String),
}
impl Result {
    pub fn message(&self) -> String {
        match self {
            Self::Ok(_) => "Ok".to_string(),
            Self::Err(_) => "Err".to_string(),
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
enum Message {
    Quit,
    Move(i64, i64),
    Write(String),
    ChangeColor(i64, i64, i64),
}
impl Message {
    pub fn message(&self) -> String {
        match self {
            Self::Quit => "Quit".to_string(),
            Self::Move(_, _) => "Move".to_string(),
            Self::Write(_) => "Write".to_string(),
            Self::ChangeColor(_, _, _) => "ChangeColor".to_string(),
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
enum Shape {
    Circle(f64),
    Rectangle(f64, f64),
    Triangle(f64, f64),
}
impl Shape {
    pub fn message(&self) -> String {
        match self {
            Self::Circle(_) => "Circle".to_string(),
            Self::Rectangle(_, _) => "Rectangle".to_string(),
            Self::Triangle(_, _) => "Triangle".to_string(),
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
enum Status {
    Pending,
    InProgress,
    Complete,
    Failed,
}
impl Status {
    pub fn message(&self) -> String {
        match self {
            Self::Pending => "Pending".to_string(),
            Self::InProgress => "InProgress".to_string(),
            Self::Complete => "Complete".to_string(),
            Self::Failed => "Failed".to_string(),
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
enum Priority {
    Low,
    Medium,
    High,
    Critical,
}
impl Priority {
    pub fn message(&self) -> String {
        match self {
            Self::Low => "Low".to_string(),
            Self::Medium => "Medium".to_string(),
            Self::High => "High".to_string(),
            Self::Critical => "Critical".to_string(),
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
enum DataContainer {
    Empty,
    Single(i64),
    Multiple(Vec<i64>),
    Mapped(std::collections::HashMap<String, i64>),
}
impl DataContainer {
    pub fn message(&self) -> String {
        match self {
            Self::Empty => "Empty".to_string(),
            Self::Single(_) => "Single".to_string(),
            Self::Multiple(_) => "Multiple".to_string(),
            Self::Mapped(_) => "Mapped".to_string(),
        }
    }
}
fn get_color_name(color: Color) -> String {
    match color {
        Color::Red => {
            return "red".to_string();
        }
        Color::Green => {
            return "green".to_string();
        }
        Color::Blue => {
            return "blue".to_string();
        }
    };
}
fn process_maybe(value: Maybe) -> i64 {
    match value {
        Maybe::Some(x) => {
            return x * 2;
        }
        Maybe::None => {
            return -1;
        }
    };
}
fn handle_result(result: Result) -> String {
    match result {
        Result::Ok(value) => {
            return format!("Success: {}", value);
        }
        Result::Err(error) => {
            return format!("Error: {}", error);
        }
    };
}
fn handle_message(msg: Message) -> String {
    match msg {
        Message::Quit => {
            return "Quitting".to_string();
        }
        Message::Move(x, y) => {
            return format!("Moving to ({}, {})", x, y);
        }
        Message::Write(text) => {
            return format!("Writing: {}", text);
        }
        Message::ChangeColor(r, g, b) => {
            return format!("Color: RGB({}, {}, {})", r, g, b);
        }
    };
}
fn calculate_area(shape: Shape) -> f64 {
    match shape {
        Shape::Circle(r) => {
            return 3.14159f64 * r * r;
        }
        Shape::Rectangle(w, h) => {
            return w * h;
        }
        Shape::Triangle(b, h) => {
            return 0.5f64 * b * h;
        }
    };
}
fn get_priority_level(priority: Priority) -> i64 {
    match priority {
        Priority::Low => {
            return 1;
        }
        Priority::Medium => {
            return 2;
        }
        Priority::High => {
            return 3;
        }
        Priority::Critical => {
            return 4;
        }
    };
}
fn count_items(container: DataContainer) -> i64 {
    match container {
        DataContainer::Empty => {
            return 0;
        }
        DataContainer::Single(_) => {
            return 1;
        }
        DataContainer::Multiple(items) => {
            return items.len() as i64;
        }
        DataContainer::Mapped(map) => {
            return map.len() as i64;
        }
    };
}
fn main() {
    let color = Color::Red;
    let color_name = get_color_name(color.clone());
    println!("{}", format!("Color: {}", color_name));
    let some_value = Maybe::Some(42);
    let none_value = Maybe::None;
    let result1 = process_maybe(some_value.clone());
    let result2 = process_maybe(none_value.clone());
    println!("{}", format!("Some: {}, None: {}", result1, result2));
    let ok_result = Result::Ok(100);
    let err_result = Result::Err("Something went wrong".to_string());
    let ok_msg = handle_result(ok_result.clone());
    let err_msg = handle_result(err_result.clone());
    println!("{}", ok_msg);
    println!("{}", err_msg);
    let quit_msg = Message::Quit;
    let move_msg = Message::Move(10, 20);
    let write_msg = Message::Write("Hello".to_string());
    let color_msg = Message::ChangeColor(255, 0, 0);
    println!("{}", handle_message(quit_msg.clone()));
    println!("{}", handle_message(move_msg.clone()));
    println!("{}", handle_message(write_msg.clone()));
    println!("{}", handle_message(color_msg.clone()));
    let circle = Shape::Circle(5f64);
    let rectangle = Shape::Rectangle(4f64, 6f64);
    let triangle = Shape::Triangle(3f64, 8f64);
    let circle_area = calculate_area(circle.clone());
    let rect_area = calculate_area(rectangle.clone());
    let tri_area = calculate_area(triangle.clone());
    println!("{}", format!("Circle area: {}", circle_area));
    println!("{}", format!("Rectangle area: {}", rect_area));
    println!("{}", format!("Triangle area: {}", tri_area));
    let status = Status::InProgress;
    let priority = Priority::High;
    let priority_level = get_priority_level(priority.clone());
    println!("{}", format!("Priority level: {}", priority_level));
    let empty = DataContainer::Empty;
    let single = DataContainer::Single(42);
    let multiple = DataContainer::Multiple(vec![1, 2, 3, 4, 5]);
    let mapped = DataContainer::Mapped(
        [("a", 1), ("b", 2), ("c", 3)].into_iter().collect::<HashMap<_, _>>(),
    );
    println!("{}", format!("Empty count: {}", count_items(empty.clone())));
    println!("{}", format!("Single count: {}", count_items(single.clone())));
    println!("{}", format!("Multiple count: {}", count_items(multiple.clone())));
    println!("{}", format!("Mapped count: {}", count_items(mapped.clone())));
}
