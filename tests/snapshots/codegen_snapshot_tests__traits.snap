---
source: tests/codegen_snapshot_tests.rs
expression: rust_code
---
// Generated by the Incan compiler v<INCAN_VERSION>

#![allow(unused_imports, dead_code, unused_variables)]

// __INCAN_INSERT_MODS__

use incan_stdlib::prelude::*;
use incan_derive::{FieldInfo, IncanClass};
pub trait Named {}
pub trait Drawable {
    fn draw(&self) -> String;
}
pub trait Shape {
    fn area(&self) -> f64;
    fn perimeter(&self) -> f64;
}
pub trait Comparable {
    fn compare(&self, other: _) -> i64;
    fn is_equal(&self, other: _) -> bool;
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
struct Dog {
    name: String,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
fn Dog(name: String) -> Dog {
    Dog { name }
}
impl Named for Dog {}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
struct Rectangle {
    width: f64,
    height: f64,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
fn Rectangle(width: f64, height: f64) -> Rectangle {
    Rectangle { width, height }
}
impl Rectangle {
    fn area(&self) -> f64 {
        return self.width * self.height;
    }
    fn perimeter(&self) -> f64 {
        return 2f64 * self.width + self.height;
    }
}
impl Shape for Rectangle {
    fn area(&self) -> f64 {
        return self.width * self.height;
    }
    fn perimeter(&self) -> f64 {
        return 2f64 * self.width + self.height;
    }
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
struct Circle {
    radius: f64,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
fn Circle(radius: f64) -> Circle {
    Circle { radius }
}
impl Circle {
    fn draw(&self) -> String {
        return format!("Circle with radius {}", self.radius);
    }
}
impl Drawable for Circle {
    fn draw(&self) -> String {
        return format!("Circle with radius {}", self.radius);
    }
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
struct Square {
    side: f64,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
fn Square(side: f64) -> Square {
    Square { side }
}
impl Square {
    fn area(&self) -> f64 {
        return self.side * self.side;
    }
    fn perimeter(&self) -> f64 {
        return 4f64 * self.side;
    }
    fn draw(&self) -> String {
        return format!("Square with side {}", self.side);
    }
}
impl Shape for Square {
    fn area(&self) -> f64 {
        return self.side * self.side;
    }
    fn perimeter(&self) -> f64 {
        return 4f64 * self.side;
    }
}
impl Drawable for Square {
    fn draw(&self) -> String {
        return format!("Square with side {}", self.side);
    }
}
pub trait Resizable {
    fn resize(&self, factor: f64);
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
struct Carton {
    width: f64,
    height: f64,
    depth: f64,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
fn Carton(width: f64, height: f64, depth: f64) -> Carton {
    Carton { width, height, depth }
}
impl Carton {
    fn resize(&self, factor: f64) {
        self.width = self.width * factor;
        self.height = self.height * factor;
        self.depth = self.depth * factor;
    }
    fn volume(&self) -> f64 {
        return self.width * self.height * self.depth;
    }
}
impl Resizable for Carton {
    fn resize(&self, factor: f64) {
        self.width = self.width * factor;
        self.height = self.height * factor;
        self.depth = self.depth * factor;
    }
}
pub trait Printable {
    fn to_string(&self) -> String;
}
pub trait Serializable {
    fn serialize(&self) -> String;
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
struct Document {
    title: String,
    content: String,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
fn Document(title: String, content: String) -> Document {
    Document { title, content }
}
impl Document {
    fn to_string(&self) -> String {
        return format!("{}: {}", self.title, self.content);
    }
    fn serialize(&self) -> String {
        return format!("title={},content={}", self.title, self.content);
    }
}
impl Printable for Document {
    fn to_string(&self) -> String {
        return format!("{}: {}", self.title, self.content);
    }
}
impl Serializable for Document {
    fn serialize(&self) -> String {
        return format!("title={},content={}", self.title, self.content);
    }
}
fn draw_shape(shape: Drawable) {
    let output = shape.draw();
    println!("{}", output);
}
fn calculate_area(shape: Shape) -> f64 {
    return shape.area();
}
fn main() {
    let dog = Dog("Buddy".to_string());
    println!("{}", format!("Dog name: {}", dog.name));
    let rect = Rectangle(5f64, 3f64);
    let rect_area = rect.area();
    let rect_perimeter = rect.perimeter();
    println!(
        "{}", format!("Rectangle area: {}, perimeter: {}", rect_area, rect_perimeter)
    );
    let circle = Circle(2.5f64);
    let circle_drawing = circle.draw();
    println!("{}", circle_drawing);
    let square = Square(4f64);
    let square_area = square.area();
    let square_drawing = square.draw();
    println!("{}", format!("Square area: {}", square_area));
    println!("{}", square_drawing);
    let mut carton = Carton(2f64, 3f64, 4f64);
    let original_volume = carton.volume();
    println!("{}", format!("Original volume: {}", original_volume));
    carton.resize(2f64);
    let new_volume = carton.volume();
    println!("{}", format!("New volume: {}", new_volume));
    let doc = Document("README".to_string(), "This is the content".to_string());
    let doc_str = doc.to_string();
    let doc_serial = doc.serialize();
    println!("{}", doc_str);
    println!("{}", doc_serial);
    draw_shape(circle.clone());
    draw_shape(square.clone());
    let area1 = calculate_area(rect.clone());
    let area2 = calculate_area(square.clone());
    println!("{}", format!("Areas: {}, {}", area1, area2));
}
