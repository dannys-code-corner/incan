---
source: tests/codegen_snapshot_tests.rs
expression: rust_code
---
// Generated by the Incan compiler v<INCAN_VERSION>

#![allow(unused_imports, dead_code, unused_variables)]

// __INCAN_INSERT_MODS__

use incan_stdlib::prelude::*;
use incan_derive::{FieldInfo, IncanClass};
pub trait Named {}
pub trait Drawable {
    fn draw(&self) -> String;
}
pub trait Shape {
    fn area(&self) -> f64;
    fn perimeter(&self) -> f64;
}
pub trait Comparable {
    fn compare(&self, other: _) -> i64;
    fn is_equal(&self, other: _) -> bool;
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
struct Dog {
    name: String,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
fn Dog(name: String) -> Dog {
    Dog { name }
}
impl Named for Dog {}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
struct Rectangle {
    width: f64,
    height: f64,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
fn Rectangle(width: f64, height: f64) -> Rectangle {
    Rectangle { width, height }
}
impl Rectangle {
    fn area(&self) -> f64 {
        return self.width * self.height;
    }
    fn perimeter(&self) -> f64 {
        return 2f64 * self.width + self.height;
    }
}
impl Shape for Rectangle {
    fn area(&self) -> f64 {
        return self.width * self.height;
    }
    fn perimeter(&self) -> f64 {
        return 2f64 * self.width + self.height;
    }
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
struct Circle {
    radius: f64,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
fn Circle(radius: f64) -> Circle {
    Circle { radius }
}
impl Circle {
    fn draw(&self) -> String {
        return {
            let __parts: [&str; 2usize] = ["Circle with radius ", ""];
            let __args: Vec<String> = vec![format!("{}", self.radius)];
            incan_stdlib::strings::fstring(&__parts, &__args)
        };
    }
}
impl Drawable for Circle {
    fn draw(&self) -> String {
        return {
            let __parts: [&str; 2usize] = ["Circle with radius ", ""];
            let __args: Vec<String> = vec![format!("{}", self.radius)];
            incan_stdlib::strings::fstring(&__parts, &__args)
        };
    }
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
struct Square {
    side: f64,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
fn Square(side: f64) -> Square {
    Square { side }
}
impl Square {
    fn area(&self) -> f64 {
        return self.side * self.side;
    }
    fn perimeter(&self) -> f64 {
        return 4f64 * self.side;
    }
    fn draw(&self) -> String {
        return {
            let __parts: [&str; 2usize] = ["Square with side ", ""];
            let __args: Vec<String> = vec![format!("{}", self.side)];
            incan_stdlib::strings::fstring(&__parts, &__args)
        };
    }
}
impl Shape for Square {
    fn area(&self) -> f64 {
        return self.side * self.side;
    }
    fn perimeter(&self) -> f64 {
        return 4f64 * self.side;
    }
}
impl Drawable for Square {
    fn draw(&self) -> String {
        return {
            let __parts: [&str; 2usize] = ["Square with side ", ""];
            let __args: Vec<String> = vec![format!("{}", self.side)];
            incan_stdlib::strings::fstring(&__parts, &__args)
        };
    }
}
pub trait Resizable {
    fn resize(&self, factor: f64);
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
struct Carton {
    width: f64,
    height: f64,
    depth: f64,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
fn Carton(width: f64, height: f64, depth: f64) -> Carton {
    Carton { width, height, depth }
}
impl Carton {
    fn resize(&self, factor: f64) {
        self.width = self.width * factor;
        self.height = self.height * factor;
        self.depth = self.depth * factor;
    }
    fn volume(&self) -> f64 {
        return self.width * self.height * self.depth;
    }
}
impl Resizable for Carton {
    fn resize(&self, factor: f64) {
        self.width = self.width * factor;
        self.height = self.height * factor;
        self.depth = self.depth * factor;
    }
}
pub trait Printable {
    fn to_string(&self) -> String;
}
pub trait Serializable {
    fn serialize(&self) -> String;
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
struct Document {
    title: String,
    content: String,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
fn Document(title: String, content: String) -> Document {
    Document { title, content }
}
impl Document {
    fn to_string(&self) -> String {
        return {
            let __parts: [&str; 3usize] = ["", ": ", ""];
            let __args: Vec<String> = vec![
                format!("{}", self.title), format!("{}", self.content)
            ];
            incan_stdlib::strings::fstring(&__parts, &__args)
        };
    }
    fn serialize(&self) -> String {
        return {
            let __parts: [&str; 3usize] = ["title=", ",content=", ""];
            let __args: Vec<String> = vec![
                format!("{}", self.title), format!("{}", self.content)
            ];
            incan_stdlib::strings::fstring(&__parts, &__args)
        };
    }
}
impl Printable for Document {
    fn to_string(&self) -> String {
        return {
            let __parts: [&str; 3usize] = ["", ": ", ""];
            let __args: Vec<String> = vec![
                format!("{}", self.title), format!("{}", self.content)
            ];
            incan_stdlib::strings::fstring(&__parts, &__args)
        };
    }
}
impl Serializable for Document {
    fn serialize(&self) -> String {
        return {
            let __parts: [&str; 3usize] = ["title=", ",content=", ""];
            let __args: Vec<String> = vec![
                format!("{}", self.title), format!("{}", self.content)
            ];
            incan_stdlib::strings::fstring(&__parts, &__args)
        };
    }
}
fn draw_shape(shape: Drawable) {
    let output = shape.draw();
    println!("{}", output);
}
fn calculate_area(shape: Shape) -> f64 {
    return shape.area();
}
fn main() {
    let dog = Dog { name: "Buddy".to_string() };
    println!(
        "{}", { let __parts : [& str; 2usize] = ["Dog name: ", ""]; let __args : Vec <
        String > = vec![format!("{}", dog.name)]; incan_stdlib::strings::fstring(&
        __parts, & __args) }
    );
    let rect = Rectangle {
        width: 5f64,
        height: 3f64,
    };
    let rect_area = rect.area();
    let rect_perimeter = rect.perimeter();
    println!(
        "{}", { let __parts : [& str; 3usize] = ["Rectangle area: ", ", perimeter: ",
        ""]; let __args : Vec < String > = vec![format!("{}", rect_area), format!("{}",
        rect_perimeter)]; incan_stdlib::strings::fstring(& __parts, & __args) }
    );
    let circle = Circle { radius: 2.5f64 };
    let circle_drawing = circle.draw();
    println!("{}", circle_drawing);
    let square = Square { side: 4f64 };
    let square_area = square.area();
    let square_drawing = square.draw();
    println!(
        "{}", { let __parts : [& str; 2usize] = ["Square area: ", ""]; let __args : Vec <
        String > = vec![format!("{}", square_area)]; incan_stdlib::strings::fstring(&
        __parts, & __args) }
    );
    println!("{}", square_drawing);
    let mut carton = Carton {
        width: 2f64,
        height: 3f64,
        depth: 4f64,
    };
    let original_volume = carton.volume();
    println!(
        "{}", { let __parts : [& str; 2usize] = ["Original volume: ", ""]; let __args :
        Vec < String > = vec![format!("{}", original_volume)];
        incan_stdlib::strings::fstring(& __parts, & __args) }
    );
    carton.resize(2f64);
    let new_volume = carton.volume();
    println!(
        "{}", { let __parts : [& str; 2usize] = ["New volume: ", ""]; let __args : Vec <
        String > = vec![format!("{}", new_volume)]; incan_stdlib::strings::fstring(&
        __parts, & __args) }
    );
    let doc = Document {
        title: "README".to_string(),
        content: "This is the content".to_string(),
    };
    let doc_str = doc.to_string();
    let doc_serial = doc.serialize();
    println!("{}", doc_str);
    println!("{}", doc_serial);
    draw_shape(circle.clone());
    draw_shape(square.clone());
    let area1 = calculate_area(rect.clone());
    let area2 = calculate_area(square.clone());
    println!(
        "{}", { let __parts : [& str; 3usize] = ["Areas: ", ", ", ""]; let __args : Vec <
        String > = vec![format!("{}", area1), format!("{}", area2)];
        incan_stdlib::strings::fstring(& __parts, & __args) }
    );
}
