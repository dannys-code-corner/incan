---
source: tests/codegen_snapshot_tests.rs
expression: rust_code
---
// Generated by the Incan compiler v<INCAN_VERSION>

#![allow(unused_imports, dead_code, unused_variables)]

// __INCAN_INSERT_MODS__

use incan_stdlib::prelude::*;
use incan_derive::{FieldInfo, IncanClass};
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
#[derive(Debug, Clone, FieldInfo, IncanClass)]
struct User {
    name: String,
    age: i64,
    email: String,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
fn User(name: String, age: i64, email: String) -> User {
    User { name, age, email }
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
struct Product {
    id: i64,
    name: String,
    price: f64,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
fn Product(id: i64, name: String, price: f64) -> Product {
    Product { id, name, price }
}
#[derive(Clone, Debug, FieldInfo, IncanClass)]
struct Config {
    host: String,
    port: i64,
    timeout: i64,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
fn Config(host: String, port: i64, timeout: i64) -> Config {
    Config { host, port, timeout }
}
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, FieldInfo, IncanClass)]
struct ApiRequest {
    endpoint: String,
    method: String,
    payload: String,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
fn ApiRequest(endpoint: String, method: String, payload: String) -> ApiRequest {
    ApiRequest {
        endpoint,
        method,
        payload,
    }
}
impl ApiRequest {
    /// Serialize this model to a JSON string
    pub fn to_json(&self) -> String {
        serde_json::to_string(self).expect("JSONError: failed to serialize to JSON")
    }
    /// Deserialize a JSON string into this model
    pub fn from_json(json_str: String) -> Result<Self, String> {
        serde_json::from_str(&json_str).map_err(|e| e.to_string())
    }
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
struct Point {
    x: i64,
    y: i64,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
fn Point(x: i64, y: i64) -> Point {
    Point { x, y }
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
struct OptionalData {
    required: String,
    optional: Option<String>,
    maybe_number: Option<i64>,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
fn OptionalData(
    required: String,
    optional: Option<String>,
    maybe_number: Option<i64>,
) -> OptionalData {
    OptionalData {
        required,
        optional,
        maybe_number,
    }
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
struct StudentData {
    name: String,
    grades: Vec<i64>,
    metadata: std::collections::HashMap<String, String>,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
fn StudentData(
    name: String,
    grades: Vec<i64>,
    metadata: std::collections::HashMap<String, String>,
) -> StudentData {
    StudentData {
        name,
        grades,
        metadata,
    }
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
struct ComplexModel {
    ids: Vec<i64>,
    mapping: std::collections::HashMap<String, i64>,
    optional_list: Option<Vec<String>>,
    nested_dict: std::collections::HashMap<String, Vec<i64>>,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
fn ComplexModel(
    ids: Vec<i64>,
    mapping: std::collections::HashMap<String, i64>,
    optional_list: Option<Vec<String>>,
    nested_dict: std::collections::HashMap<String, Vec<i64>>,
) -> ComplexModel {
    ComplexModel {
        ids,
        mapping,
        optional_list,
        nested_dict,
    }
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
struct Address {
    street: String,
    city: String,
    zipcode: String,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
fn Address(street: String, city: String, zipcode: String) -> Address {
    Address { street, city, zipcode }
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
struct Contact {
    name: String,
    address: Address,
    phone: String,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
fn Contact(name: String, address: Address, phone: String) -> Contact {
    Contact { name, address, phone }
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
struct Coordinate {
    latitude: f64,
    longitude: f64,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
fn Coordinate(latitude: f64, longitude: f64) -> Coordinate {
    Coordinate { latitude, longitude }
}
fn create_coordinate(lat: f64, lon: f64) -> Coordinate {
    return Coordinate {
        latitude: lat,
        longitude: lon,
    };
}
fn distance_from_origin(coord: Coordinate) -> f64 {
    let lat_sq = coord.latitude * coord.latitude;
    let lon_sq = coord.longitude * coord.longitude;
    return lat_sq + lon_sq.powf(0.5f64);
}
fn main() {
    let user = User {
        name: "Alice".to_string(),
        age: 30,
        email: "alice@example.com".to_string(),
    };
    println!(
        "{}", { let __parts : [& str; 3usize] = ["User: ", ", Age: ", ""]; let __args :
        Vec < String > = vec![format!("{}", user.name), format!("{}", user.age)];
        incan_stdlib::strings::fstring(& __parts, & __args) }
    );
    let product = Product {
        id: 123,
        name: "Laptop".to_string(),
        price: 999.99f64,
    };
    println!(
        "{}", { let __parts : [& str; 2usize] = ["Product ID: ", ""]; let __args : Vec <
        String > = vec![format!("{}", product.id)]; incan_stdlib::strings::fstring(&
        __parts, & __args) }
    );
    let config = Config {
        host: "localhost".to_string(),
        port: 8080,
        timeout: 30,
    };
    let config_copy = config.clone();
    println!(
        "{}", { let __parts : [& str; 2usize] = ["Config port: ", ""]; let __args : Vec <
        String > = vec![format!("{}", config_copy.port)];
        incan_stdlib::strings::fstring(& __parts, & __args) }
    );
    let data1 = OptionalData {
        required: "must have".to_string(),
        optional: Some("optional value".to_string()),
        maybe_number: Some(42),
    };
    let data2 = OptionalData {
        required: "also must have".to_string(),
        optional: (),
        maybe_number: (),
    };
    let student = StudentData {
        name: "Bob".to_string(),
        grades: vec![85, 90, 88, 92],
        metadata: [("school", "MIT"), ("year", "2024")]
            .into_iter()
            .collect::<HashMap<_, _>>(),
    };
    println!(
        "{}", { let __parts : [& str; 2usize] = ["Student: ", ""]; let __args : Vec <
        String > = vec![format!("{}", student.name)]; incan_stdlib::strings::fstring(&
        __parts, & __args) }
    );
    let coord = create_coordinate(3f64, 4f64);
    let dist = distance_from_origin(coord.clone());
    println!(
        "{}", { let __parts : [& str; 2usize] = ["Distance: ", ""]; let __args : Vec <
        String > = vec![format!("{}", dist)]; incan_stdlib::strings::fstring(& __parts, &
        __args) }
    );
    let address = Address {
        street: "123 Main St".to_string(),
        city: "Boston".to_string(),
        zipcode: "02101".to_string(),
    };
    let contact = Contact {
        name: "Charlie".to_string(),
        address: address,
        phone: "555-1234".to_string(),
    };
    println!(
        "{}", { let __parts : [& str; 3usize] = ["Contact: ", " in ", ""]; let __args :
        Vec < String > = vec![format!("{}", contact.name), format!("{}", contact.address
        .city)]; incan_stdlib::strings::fstring(& __parts, & __args) }
    );
}
