---
source: tests/codegen_snapshot_tests.rs
expression: rust_code
---
// Generated by the Incan compiler v<INCAN_VERSION>

#![allow(unused_imports, dead_code, unused_variables)]

// __INCAN_INSERT_MODS__

use incan_stdlib::prelude::*;
use incan_derive::{FieldInfo, IncanClass};
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
#[derive(Debug, Clone, FieldInfo, IncanClass)]
pub struct User {
    pub name: String,
    pub age: i64,
    pub email: String,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
pub fn User(name: String, age: i64, email: String) -> User {
    User { name, age, email }
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
pub struct Product {
    pub id: i64,
    pub name: String,
    pub price: f64,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
pub fn Product(id: i64, name: String, price: f64) -> Product {
    Product { id, name, price }
}
#[derive(Clone, Debug, FieldInfo, IncanClass)]
pub struct Config {
    pub host: String,
    pub port: i64,
    pub timeout: i64,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
pub fn Config(host: String, port: i64, timeout: i64) -> Config {
    Config { host, port, timeout }
}
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, FieldInfo, IncanClass)]
pub struct ApiRequest {
    pub endpoint: String,
    pub method: String,
    pub payload: String,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
pub fn ApiRequest(endpoint: String, method: String, payload: String) -> ApiRequest {
    ApiRequest {
        endpoint,
        method,
        payload,
    }
}
impl ApiRequest {
    /// Serialize this model to a JSON string
    pub fn to_json(&self) -> String {
        serde_json::to_string(self).expect("JSONError: failed to serialize to JSON")
    }
    /// Deserialize a JSON string into this model
    pub fn from_json(json_str: String) -> Result<Self, String> {
        serde_json::from_str(&json_str).map_err(|e| e.to_string())
    }
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
pub struct Point {
    pub x: i64,
    pub y: i64,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
pub fn Point(x: i64, y: i64) -> Point {
    Point { x, y }
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
pub struct OptionalData {
    pub required: String,
    pub optional: Option<String>,
    pub maybe_number: Option<i64>,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
pub fn OptionalData(
    required: String,
    optional: Option<String>,
    maybe_number: Option<i64>,
) -> OptionalData {
    OptionalData {
        required,
        optional,
        maybe_number,
    }
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
pub struct StudentData {
    pub name: String,
    pub grades: Vec<i64>,
    pub metadata: std::collections::HashMap<String, String>,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
pub fn StudentData(
    name: String,
    grades: Vec<i64>,
    metadata: std::collections::HashMap<String, String>,
) -> StudentData {
    StudentData {
        name,
        grades,
        metadata,
    }
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
pub struct ComplexModel {
    pub ids: Vec<i64>,
    pub mapping: std::collections::HashMap<String, i64>,
    pub optional_list: Option<Vec<String>>,
    pub nested_dict: std::collections::HashMap<String, Vec<i64>>,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
pub fn ComplexModel(
    ids: Vec<i64>,
    mapping: std::collections::HashMap<String, i64>,
    optional_list: Option<Vec<String>>,
    nested_dict: std::collections::HashMap<String, Vec<i64>>,
) -> ComplexModel {
    ComplexModel {
        ids,
        mapping,
        optional_list,
        nested_dict,
    }
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
pub struct Address {
    pub street: String,
    pub city: String,
    pub zipcode: String,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
pub fn Address(street: String, city: String, zipcode: String) -> Address {
    Address { street, city, zipcode }
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
pub struct Contact {
    pub name: String,
    pub address: Address,
    pub phone: String,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
pub fn Contact(name: String, address: Address, phone: String) -> Contact {
    Contact { name, address, phone }
}
#[derive(Debug, Clone, FieldInfo, IncanClass)]
pub struct Coordinate {
    pub latitude: f64,
    pub longitude: f64,
}
#[allow(non_snake_case, clippy::too_many_arguments)]
pub fn Coordinate(latitude: f64, longitude: f64) -> Coordinate {
    Coordinate { latitude, longitude }
}
pub fn create_coordinate(lat: f64, lon: f64) -> Coordinate {
    return Coordinate {
        latitude: lat,
        longitude: lon,
    };
}
pub fn distance_from_origin(coord: Coordinate) -> f64 {
    let lat_sq = coord.latitude * coord.latitude;
    let lon_sq = coord.longitude * coord.longitude;
    return lat_sq + lon_sq.powf(0.5f64);
}
fn main() {
    let user = User {
        name: "Alice".to_string(),
        age: 30,
        email: "alice@example.com".to_string(),
    };
    println!("{}", format!("User: {}, Age: {}", user.name, user.age));
    let product = Product {
        id: 123,
        name: "Laptop".to_string(),
        price: 999.99f64,
    };
    println!("{}", format!("Product ID: {}", product.id));
    let config = Config {
        host: "localhost".to_string(),
        port: 8080,
        timeout: 30,
    };
    let config_copy = config.clone();
    println!("{}", format!("Config port: {}", config_copy.port));
    let data1 = OptionalData {
        required: "must have".to_string(),
        optional: Some("optional value".to_string()),
        maybe_number: Some(42),
    };
    let data2 = OptionalData {
        required: "also must have".to_string(),
        optional: (),
        maybe_number: (),
    };
    let student = StudentData {
        name: "Bob".to_string(),
        grades: vec![85, 90, 88, 92],
        metadata: [("school", "MIT"), ("year", "2024")]
            .into_iter()
            .collect::<HashMap<_, _>>(),
    };
    println!("{}", format!("Student: {}", student.name));
    let coord = create_coordinate(3f64, 4f64);
    let dist = distance_from_origin(coord.clone());
    println!("{}", format!("Distance: {}", dist));
    let address = Address {
        street: "123 Main St".to_string(),
        city: "Boston".to_string(),
        zipcode: "02101".to_string(),
    };
    let contact = Contact {
        name: "Charlie".to_string(),
        address: address,
        phone: "555-1234".to_string(),
    };
    println!("{}", format!("Contact: {} in {}", contact.name, contact.address.city));
}
