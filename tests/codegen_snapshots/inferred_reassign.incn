# Inferred reassignment semantics

# Simple mutable variable bump without shadowing

def bump() -> int:
    mut x = 1
    x = x + 1
    return x

# Collatz inner loop: ensure reassignments in branches do not shadow

def collatz_inner(n: int) -> int:
    mut num = n
    while num != 1:
        if num % 2 == 0:
            num = num / 2
        else:
            num = 3 * num + 1
    return num

# Reassignment in an if-block

def reassign_in_if() -> int:
    mut status = 0
    if status == 0:
        status = 1
    return status
