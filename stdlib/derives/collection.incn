"""
Collection-related traits: Bool, Len, Contains, Iterable, Iterator
These traits enable Python-like collection behavior for custom types.
"""


trait Contains[T]:
    """
    Contains trait - Enables `item in collection` membership testing
    Python equivalent: __contains__
    
    Example:

    ```incan
    model UniqueSet[T] with Contains[T]:
        items: List[T]
        
        def __contains__(self, item: T) -> bool:
            for x in self.items:
                if x == item:
                    return true
            return false

    numbers = UniqueSet(items=[1, 2, 3, 4, 5])
    
    if 3 in numbers:
        println("Found 3!")
    
    if 99 not in numbers:
        println("99 not found")
    ```
    
    Note: Built-in types (List, Set, Dict, str) already support `in`.
    Implement __contains__ for custom collection types.
    """
    def __contains__(self, item: T) -> bool: ...


trait Bool:
    """
    Bool trait - Enables truthiness testing with `if obj:` syntax
    Python equivalent: __bool__
    
    ⚠️  DISCOURAGED: Prefer explicit checks over implicit truthiness.
    
    Incan encourages explicit patterns:

    ```incan
    if user is Some(u):      # Option unwrapping
    if len(items) > 0:       # Length check  
    if name != "":           # Empty check
    if conn.is_connected:    # Named boolean
    ```
    
    These are clearer than `if obj:` which hides what's being checked.
    
    However, if truthiness genuinely fits your type, you may implement it:
    
    ```incan
    model NonEmptyString with Bool:
        value: str
        
        def __bool__(self) -> bool:
            return len(self.value) > 0
    ```

    Note: Bool cannot be derived with @derive(Bool). You must implement `__bool__` manually. 
        This is intentional — "explicit is better than implicit!"
    """
    def __bool__(self) -> bool: ...


trait Len:
    """
    Len trait - Enables len() builtin for custom types
    Python equivalent: __len__
    
    ⚠️ Note: Len cannot be auto-derived — you must implement __len__ manually because the compiler can't know what 
    "length" means for your type.
    
    Examples:

    ```incan
    model Queue[T] with Len:
        items: List[T]
        
        def __len__(self) -> int:
            return len(self.items)

    q = Queue(items=[1, 2, 3])
    println(f"Queue has {len(q)} items")  # Queue has 3 items
    ```
    
    Common patterns:

    ```incan
    # Wrapper around collection
    def __len__(self) -> int:
        return len(self.items)
    
    # Computed length
    def __len__(self) -> int:
        return self.end - self.start
    ```
    """
    def __len__(self) -> int: ...


trait Iterable[T]:
    """
    Iterable trait - Enables `for item in obj:` syntax
    Python equivalent: __iter__
    
    Returns an iterator that can be used in for loops.
    
    Example:

    ```incan
    model NumberRange with Iterable[int]:
        start: int
        end: int
        
        def __iter__(self) -> Iterator[int]:
            return RangeIterator(current=self.start, end=self.end)

    nums = NumberRange(start=0, end=5)
    for n in nums:
        println(n)  # 0, 1, 2, 3, 4
    ```
    """
    def __iter__(self) -> Iterator[T]: ...


trait Iterator[T]:
    """
    Iterator trait - The actual iteration mechanism
    Python equivalent: __next__
    
    Returns the next item, or None when exhausted.
    
    Examples:

    ```incan
    model RangeIterator with Iterator[int]:
        current: int
        end: int
        
        def __next__(self) -> Option[int]:
            if self.current >= self.end:
                return None
            value = self.current
            self.current += 1
            return Some(value)
    ```
    
    Note: In Incan, __next__ returns Option[T] instead of raising StopIteration.
    This is more Rust-like and avoids exception overhead.
    """
    def __next__(self) -> Option[T]: ...
