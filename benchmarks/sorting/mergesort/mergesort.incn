# Mergesort Benchmark
# Sort 1,000,000 random integers (with allocation)

def mergesort(arr: List[int]) -> List[int]:
    n = len(arr)
    if n <= 1:
        return arr

    # NOTE (Python mental model):
    # We sort by *mutating* a local list (`out`) in place, rather than returning new sub-lists from recursive calls.
    # This avoids `arr[a:b]` slice allocations at each recursion level.
    #
    # This is closer to how you'd implement a fast mergesort in Rust/C: a single scratch buffer is allocated once and
    # reused throughout the recursion.
    mut out = arr

    # Allocate scratch once (same length as `out`) and reuse it for all merges.
    mut temp: List[int] = []
    temp.reserve(n)
    for _ in range(n):
        temp.append(0)

    # Sort the range [0, n) by mutating `out` in place (no return value).
    mergesort_range(out, temp, 0, n)
    return out

def mergesort_range(mut arr: List[int], mut temp: List[int], lo: int, hi: int) -> None:
    # Sorts arr[lo:hi) *in place* by overwriting elements of `arr`.
    # This returns None because the result is the side effect on `arr`.
    if hi - lo <= 1:
        return

    mid = (lo + hi) // 2
    mergesort_range(arr, temp, lo, mid)
    mergesort_range(arr, temp, mid, hi)
    merge_range(arr, temp, lo, mid, hi)

def merge_range(mut arr: List[int], mut temp: List[int], lo: int, mid: int, hi: int) -> None:
    # Merge arr[lo:mid) and arr[mid:hi) into temp[lo:hi), then copy back.
    # (So `arr` is what ends up sorted.)
    mut i = lo
    mut j = mid
    mut k = lo

    while i < mid and j < hi:
        if arr[i] <= arr[j]:
            temp[k] = arr[i]
            i += 1
        else:
            temp[k] = arr[j]
            j += 1
        k += 1

    while i < mid:
        temp[k] = arr[i]
        i += 1
        k += 1

    while j < hi:
        temp[k] = arr[j]
        j += 1
        k += 1

    for idx in range(lo..hi):
        arr[idx] = temp[idx]
        
def generate_random_array(size: int, seed: int) -> List[int]:
    mut arr: List[int] = []
    mut state = seed
    for _ in range(size):
        state = (state * 1103515245 + 12345) % 2147483648
        arr.append(state % 1000000)
    return arr

def main() -> None:
    size = 1_000_000
    arr = generate_random_array(size, 42)
    sorted_arr = mergesort(arr)
    println(f"Sorted {size} elements")
    println(f"First 5: {sorted_arr[0]}, {sorted_arr[1]}, {sorted_arr[2]}, {sorted_arr[3]}, {sorted_arr[4]}")
