//! Import statement handling for code generation
//!
//! Handles emitting use statements and the prelude.

use crate::frontend::ast::*;

use super::RustCodegen;

// Standard Incan prelude imports that should not be emitted as Rust import
const PRELUDE_IMPORT_PREFIXES: &[&str] = &["derives", "serde", "prelude", "web", "async", "testing", "this"];
const INCAN_VERSION: &str = env!("CARGO_PKG_VERSION");

impl RustCodegen<'_> {
    /// Check if a module path is a prelude/stdlib module that shouldn't be emitted as Rust import
    pub(crate) fn is_prelude_import(path: &ImportPath) -> bool {
        if path.segments.is_empty() {
            return false;
        }
        let first = path.segments[0].as_str();
        // Skip stdlib imports (derives, serde, prelude, web, async, testing)
        PRELUDE_IMPORT_PREFIXES.contains(&first)
    }

    /// Emit the prelude (standard imports)
    pub(crate) fn emit_prelude(&mut self) {
        self.emitter
            .comment(&format!("Generated by the Incan compiler v{}", INCAN_VERSION));
        self.emitter.blank_line();
        // TODO: fix this more properly in a future release
        //   Suppress unused import warnings (codegen emits common imports proactively)
        self.emitter.line("#![allow(unused_imports, unused_parens)]");
        self.emitter.blank_line();
        self.emitter.use_stmt("std::collections::{HashMap, HashSet}");
        if self.needs_serde {
            self.emitter.use_stmt("serde::{Serialize, Deserialize}");
        }
        if self.needs_tokio {
            self.emitter.use_stmt("tokio::time::{sleep, timeout, Duration}");
            self.emitter.use_stmt("tokio::sync::{mpsc, Mutex, RwLock}");
            self.emitter.use_stmt("tokio::task::JoinHandle");
        }
        if self.needs_axum {
            self.emitter.use_stmt("axum::{Router, routing::{get, post, put, delete, patch}, Json, response::{Html, IntoResponse, Response}, extract::{Path, Query, State}}");
            self.emitter.use_stmt("std::net::SocketAddr");
        }
        self.emitter.blank_line();

        // Emit list helper functions if needed
        if self.needs_list_helpers {
            self.emit_list_helpers();
        }
    }

    /// Emit helper functions for list operations
    fn emit_list_helpers(&mut self) {
        self.emitter.comment("Helper functions for Python-style list operations");
        self.emitter.blank_line();
        
        // Helper to find index of value in a vector
        self.emitter.line("fn __incan_list_find_index<T: PartialEq>(vec: &[T], value: &T) -> Option<usize> {");
        self.emitter.indent();
        self.emitter.line("vec.iter().position(|x| x == value)");
        self.emitter.dedent();
        self.emitter.line("}");
        self.emitter.blank_line();
    }

    /// Emit an import declaration
    pub(crate) fn emit_import(&mut self, import: &ImportDecl) {
        match &import.kind {
            ImportKind::Module(path) => {
                // Handle `import this` specially - mark for Zen emission in main()
                if path.segments.len() == 1 && path.segments[0] == "this" {
                    self.emit_zen_in_main = true;
                    return;
                }

                // Skip prelude/stdlib imports
                if Self::is_prelude_import(path) {
                    return;
                }

                let rust_path = path.to_rust_path();
                if let Some(alias) = &import.alias {
                    self.emitter.line(&format!("use {} as {};", rust_path, alias));
                } else {
                    self.emitter.use_stmt(&rust_path);
                }
            }
            ImportKind::From { module, items } => {
                // Skip prelude/stdlib imports
                if Self::is_prelude_import(module) {
                    return;
                }

                // `from module import a, b as c` -> `use module::{a, b as c};`
                let module_path = module.to_rust_path();
                if items.len() == 1 {
                    // Single item
                    let item = &items[0];
                    if let Some(alias) = &item.alias {
                        self.emitter.line(&format!("use {}::{} as {};", module_path, item.name, alias));
                    } else {
                        self.emitter.line(&format!("use {}::{};", module_path, item.name));
                    }
                } else {
                    // Multiple items - use grouped import
                    let items_str: Vec<String> = items.iter().map(|item| {
                        if let Some(alias) = &item.alias {
                            format!("{} as {}", item.name, alias)
                        } else {
                            item.name.clone()
                        }
                    }).collect();
                    self.emitter.line(&format!("use {}::{{{}}};", module_path, items_str.join(", ")));
                }
            }
            ImportKind::Python(pkg) => {
                // Python imports become comments for now
                self.emitter.comment(&format!("Python import: {} (not supported in Rust)", pkg));
                // TODO: we might consider adding support for Python imports in the future, should the demand arise
            }
            ImportKind::RustCrate { crate_name, path } => {
                // import rust::serde_json -> use serde_json;
                // Track crate for Cargo.toml generation (skip std which is always available)
                if crate_name != "std" {
                    self.rust_crates.insert(crate_name.clone());
                }

                let full_path = if path.is_empty() {
                    crate_name.clone()
                } else {
                    format!("{}::{}", crate_name, path.join("::"))
                };
                if let Some(alias) = &import.alias {
                    self.emitter.line(&format!("use {} as {};", full_path, alias));
                } else {
                    self.emitter.line(&format!("use {};", full_path));
                }
            }
            ImportKind::RustFrom { crate_name, path, items } => {
                // from rust::time import Instant -> use time::Instant;
                // Track crate for Cargo.toml generation (skip std which is always available)
                if crate_name != "std" {
                    self.rust_crates.insert(crate_name.clone());
                }

                // Skip imports that are already in the prelude
                let prelude_imports = ["HashMap", "HashSet"];
                let is_collections = crate_name == "std" && path.first().map(|s| s.as_str()) == Some("collections");
                let filtered_items: Vec<_> = items.iter()
                    .filter(|item| !(is_collections && prelude_imports.contains(&item.name.as_str()) && item.alias.is_none()))
                    .collect();

                if filtered_items.is_empty() {
                    // All items were filtered out (already in prelude)
                    return;
                }

                let base_path = if path.is_empty() {
                    crate_name.clone()
                } else {
                    format!("{}::{}", crate_name, path.join("::"))
                };

                if filtered_items.len() == 1 {
                    let item = &filtered_items[0];
                    if let Some(alias) = &item.alias {
                        self.emitter.line(&format!("use {}::{} as {};", base_path, item.name, alias));
                    } else {
                        self.emitter.line(&format!("use {}::{};", base_path, item.name));
                    }
                } else {
                    let items_str: Vec<String> = filtered_items.iter().map(|item| {
                        if let Some(alias) = &item.alias {
                            format!("{} as {}", item.name, alias)
                        } else {
                            item.name.clone()
                        }
                    }).collect();
                    self.emitter.line(&format!("use {}::{{{}}};", base_path, items_str.join(", ")));
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::backend::codegen::RustCodegen;

    // ========================================
    // is_prelude_import tests
    // ========================================

    #[test]
    fn test_is_prelude_import_empty() {
        let path = ImportPath {
            segments: vec![],
            is_absolute: false,
            parent_levels: 0,
        };
        assert!(!RustCodegen::is_prelude_import(&path));
    }

    #[test]
    fn test_is_prelude_import_derives() {
        let path = ImportPath {
            segments: vec!["derives".to_string()],
            is_absolute: false,
            parent_levels: 0,
        };
        assert!(RustCodegen::is_prelude_import(&path));
    }

    #[test]
    fn test_is_prelude_import_serde() {
        let path = ImportPath {
            segments: vec!["serde".to_string(), "Serialize".to_string()],
            is_absolute: false,
            parent_levels: 0,
        };
        assert!(RustCodegen::is_prelude_import(&path));
    }

    #[test]
    fn test_is_prelude_import_prelude() {
        let path = ImportPath {
            segments: vec!["prelude".to_string()],
            is_absolute: false,
            parent_levels: 0,
        };
        assert!(RustCodegen::is_prelude_import(&path));
    }

    #[test]
    fn test_is_prelude_import_web() {
        let path = ImportPath {
            segments: vec!["web".to_string()],
            is_absolute: false,
            parent_levels: 0,
        };
        assert!(RustCodegen::is_prelude_import(&path));
    }

    #[test]
    fn test_is_prelude_import_async() {
        let path = ImportPath {
            segments: vec!["async".to_string()],
            is_absolute: false,
            parent_levels: 0,
        };
        assert!(RustCodegen::is_prelude_import(&path));
    }

    #[test]
    fn test_is_prelude_import_testing() {
        let path = ImportPath {
            segments: vec!["testing".to_string()],
            is_absolute: false,
            parent_levels: 0,
        };
        assert!(RustCodegen::is_prelude_import(&path));
    }

    #[test]
    fn test_is_prelude_import_this() {
        let path = ImportPath {
            segments: vec!["this".to_string()],
            is_absolute: false,
            parent_levels: 0,
        };
        assert!(RustCodegen::is_prelude_import(&path));
    }

    #[test]
    fn test_is_prelude_import_regular_module() {
        let path = ImportPath {
            segments: vec!["models".to_string()],
            is_absolute: false,
            parent_levels: 0,
        };
        assert!(!RustCodegen::is_prelude_import(&path));
    }

    #[test]
    fn test_is_prelude_import_user_module() {
        let path = ImportPath {
            segments: vec!["user".to_string(), "data".to_string()],
            is_absolute: false,
            parent_levels: 0,
        };
        assert!(!RustCodegen::is_prelude_import(&path));
    }

    // ========================================
    // emit_prelude tests
    // ========================================

    #[test]
    fn test_emit_prelude_basic() {
        let mut codegen = RustCodegen::new();
        codegen.emit_prelude();
        let output = codegen.emitter.finish();
        assert!(output.contains("Generated by the Incan compiler v"));
        assert!(output.contains("std::collections::{HashMap, HashSet}"));
    }

    #[test]
    fn test_emit_prelude_with_serde() {
        let mut codegen = RustCodegen::new();
        codegen.needs_serde = true;
        codegen.emit_prelude();
        let output = codegen.emitter.finish();
        assert!(output.contains("serde::{Serialize, Deserialize}"));
    }

    #[test]
    fn test_emit_prelude_with_tokio() {
        let mut codegen = RustCodegen::new();
        codegen.needs_tokio = true;
        codegen.emit_prelude();
        let output = codegen.emitter.finish();
        assert!(output.contains("tokio::time"));
        assert!(output.contains("tokio::sync"));
        assert!(output.contains("JoinHandle"));
    }

    #[test]
    fn test_emit_prelude_with_axum() {
        let mut codegen = RustCodegen::new();
        codegen.needs_axum = true;
        codegen.emit_prelude();
        let output = codegen.emitter.finish();
        assert!(output.contains("axum::"));
        assert!(output.contains("Router"));
        assert!(output.contains("SocketAddr"));
    }

    #[test]
    fn test_emit_prelude_all_flags() {
        let mut codegen = RustCodegen::new();
        codegen.needs_serde = true;
        codegen.needs_tokio = true;
        codegen.needs_axum = true;
        codegen.emit_prelude();
        let output = codegen.emitter.finish();
        assert!(output.contains("serde"));
        assert!(output.contains("tokio"));
        assert!(output.contains("axum"));
    }

    // ========================================
    // emit_import tests
    // ========================================

    #[test]
    fn test_emit_import_module_simple() {
        let mut codegen = RustCodegen::new();
        let import = ImportDecl {
            kind: ImportKind::Module(ImportPath {
                segments: vec!["models".to_string()],
                is_absolute: false,
                parent_levels: 0,
            }),
            alias: None,
        };
        codegen.emit_import(&import);
        let output = codegen.emitter.finish();
        assert!(output.contains("use models;"));
    }

    #[test]
    fn test_emit_import_module_with_alias() {
        let mut codegen = RustCodegen::new();
        let import = ImportDecl {
            kind: ImportKind::Module(ImportPath {
                segments: vec!["models".to_string()],
                is_absolute: false,
                parent_levels: 0,
            }),
            alias: Some("m".to_string()),
        };
        codegen.emit_import(&import);
        let output = codegen.emitter.finish();
        assert!(output.contains("use models as m;"));
    }

    #[test]
    fn test_emit_import_skip_prelude() {
        let mut codegen = RustCodegen::new();
        let import = ImportDecl {
            kind: ImportKind::Module(ImportPath {
                segments: vec!["prelude".to_string()],
                is_absolute: false,
                parent_levels: 0,
            }),
            alias: None,
        };
        codegen.emit_import(&import);
        let output = codegen.emitter.finish();
        // Prelude imports should be skipped
        assert!(!output.contains("prelude"));
    }

    #[test]
    fn test_emit_import_python() {
        let mut codegen = RustCodegen::new();
        let import = ImportDecl {
            kind: ImportKind::Python("numpy".to_string()),
            alias: None,
        };
        codegen.emit_import(&import);
        let output = codegen.emitter.finish();
        assert!(output.contains("Python import"));
        assert!(output.contains("numpy"));
        assert!(output.contains("not supported"));
    }

    #[test]
    fn test_emit_import_rust_crate() {
        let mut codegen = RustCodegen::new();
        let import = ImportDecl {
            kind: ImportKind::RustCrate {
                crate_name: "serde_json".to_string(),
                path: vec![],
            },
            alias: None,
        };
        codegen.emit_import(&import);
        let output = codegen.emitter.finish();
        assert!(output.contains("use serde_json;"));
        assert!(codegen.rust_crates.contains("serde_json"));
    }

    #[test]
    fn test_emit_import_rust_crate_with_path() {
        let mut codegen = RustCodegen::new();
        let import = ImportDecl {
            kind: ImportKind::RustCrate {
                crate_name: "tokio".to_string(),
                path: vec!["time".to_string()],
            },
            alias: None,
        };
        codegen.emit_import(&import);
        let output = codegen.emitter.finish();
        assert!(output.contains("use tokio::time;"));
    }

    #[test]
    fn test_emit_import_rust_crate_std_not_tracked() {
        let mut codegen = RustCodegen::new();
        let import = ImportDecl {
            kind: ImportKind::RustCrate {
                crate_name: "std".to_string(),
                path: vec!["io".to_string()],
            },
            alias: None,
        };
        codegen.emit_import(&import);
        // std should not be added to rust_crates
        assert!(!codegen.rust_crates.contains("std"));
    }

    #[test]
    fn test_emit_import_from_single() {
        let mut codegen = RustCodegen::new();
        let import = ImportDecl {
            kind: ImportKind::From {
                module: ImportPath {
                    segments: vec!["models".to_string()],
                    is_absolute: false,
                    parent_levels: 0,
                },
                items: vec![ImportItem {
                    name: "User".to_string(),
                    alias: None,
                }],
            },
            alias: None,
        };
        codegen.emit_import(&import);
        let output = codegen.emitter.finish();
        assert!(output.contains("use models::User;"));
    }

    #[test]
    fn test_emit_import_from_multiple() {
        let mut codegen = RustCodegen::new();
        let import = ImportDecl {
            kind: ImportKind::From {
                module: ImportPath {
                    segments: vec!["models".to_string()],
                    is_absolute: false,
                    parent_levels: 0,
                },
                items: vec![
                    ImportItem { name: "User".to_string(), alias: None },
                    ImportItem { name: "Post".to_string(), alias: None },
                ],
            },
            alias: None,
        };
        codegen.emit_import(&import);
        let output = codegen.emitter.finish();
        assert!(output.contains("use models::{"));
        assert!(output.contains("User"));
        assert!(output.contains("Post"));
    }

    #[test]
    fn test_emit_import_from_with_alias() {
        let mut codegen = RustCodegen::new();
        let import = ImportDecl {
            kind: ImportKind::From {
                module: ImportPath {
                    segments: vec!["models".to_string()],
                    is_absolute: false,
                    parent_levels: 0,
                },
                items: vec![ImportItem {
                    name: "User".to_string(),
                    alias: Some("U".to_string()),
                }],
            },
            alias: None,
        };
        codegen.emit_import(&import);
        let output = codegen.emitter.finish();
        assert!(output.contains("use models::User as U;"));
    }

    #[test]
    fn test_emit_import_rust_from_single() {
        let mut codegen = RustCodegen::new();
        let import = ImportDecl {
            kind: ImportKind::RustFrom {
                crate_name: "time".to_string(),
                path: vec![],
                items: vec![ImportItem {
                    name: "Instant".to_string(),
                    alias: None,
                }],
            },
            alias: None,
        };
        codegen.emit_import(&import);
        let output = codegen.emitter.finish();
        assert!(output.contains("use time::Instant;"));
    }

    #[test]
    fn test_emit_import_rust_from_filtered_prelude() {
        // HashMap from std::collections should be filtered out (already in prelude)
        let mut codegen = RustCodegen::new();
        let import = ImportDecl {
            kind: ImportKind::RustFrom {
                crate_name: "std".to_string(),
                path: vec!["collections".to_string()],
                items: vec![ImportItem {
                    name: "HashMap".to_string(),
                    alias: None,
                }],
            },
            alias: None,
        };
        codegen.emit_import(&import);
        let output = codegen.emitter.finish();
        // Should be empty since HashMap is already in prelude
        assert!(!output.contains("HashMap"));
    }

    #[test]
    fn test_emit_import_this_sets_flag() {
        // `import this` should set the emit_zen_in_main flag, not emit a use statement
        let mut codegen = RustCodegen::new();
        let import = ImportDecl {
            kind: ImportKind::Module(ImportPath {
                segments: vec!["this".to_string()],
                is_absolute: false,
                parent_levels: 0,
            }),
            alias: None,
        };
        assert!(!codegen.emit_zen_in_main);
        codegen.emit_import(&import);
        let output = codegen.emitter.finish();
        // Should NOT emit `use this;`
        assert!(!output.contains("use this;"));
        // Should set the flag for emitting Zen in main
        assert!(codegen.emit_zen_in_main);
    }
}
