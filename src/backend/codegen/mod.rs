//! Rust code generation from Incan AST
//!
//! Transforms the typed AST into Rust source code.
//!
//! This module is organized into sub-modules:
//! - `types`: Helper structs (DunderMethods, RouteInfo)
//! - `type_conv`: Type conversion utilities
//! - `patterns`: Pattern matching emission
//! - `imports`: Import statement handling
//! - `statements`: Statement emission
//! - `expressions`: Expression emission
//! - `functions`: Function and method emission
//! - `declarations`: Type declaration emission (model, class, trait, etc.)

mod types;
mod type_conv;
mod patterns;
mod imports;
mod statements;
mod expressions;
mod functions;
mod declarations;

use std::collections::{HashMap, HashSet};

use crate::frontend::ast::*;
use crate::backend::rust_emitter::RustEmitter;

use types::RouteInfo;

/// Rust code generator
pub struct RustCodegen<'a> {
    pub(crate) emitter: RustEmitter,
    pub(crate) current_program: Option<&'a Program>,
    /// Dependency modules to include before main
    pub(crate) dependency_modules: Vec<&'a Program>,
    /// Whether serde is needed (for Serialize/Deserialize derives)
    pub(crate) needs_serde: bool,
    /// Whether tokio is needed (for async runtime)
    pub(crate) needs_tokio: bool,
    /// Whether axum web framework is needed
    pub(crate) needs_axum: bool,
    /// Collected routes from @route decorators
    pub(crate) routes: Vec<RouteInfo>,
    /// Whether generating in test mode (emit #[test] attributes)
    pub(crate) test_mode: bool,
    /// Specific test function to mark with #[test] (if any)
    pub(crate) test_function: Option<String>,
    /// Fixtures available for test functions (name -> (has_teardown, dependencies))
    pub(crate) fixtures: HashMap<String, (bool, Vec<String>)>,
    /// Rust crates imported via `import rust::` or `from rust::`
    pub(crate) rust_crates: HashSet<String>,
    /// Whether to emit the Zen of Incan at the start of main (set by `import this`)
    pub(crate) emit_zen_in_main: bool,
}

impl<'a> RustCodegen<'a> {
    pub fn new() -> Self {
        Self {
            emitter: RustEmitter::new(),
            current_program: None,
            dependency_modules: Vec::new(),
            needs_serde: false,
            needs_tokio: false,
            needs_axum: false,
            routes: Vec::new(),
            test_mode: false,
            test_function: None,
            fixtures: HashMap::new(),
            rust_crates: HashSet::new(),
            emit_zen_in_main: false,
        }
    }

    /// Get the Rust crates imported via `import rust::` or `from rust::`
    pub fn rust_crates(&self) -> &HashSet<String> {
        &self.rust_crates
    }

    /// Register a fixture for test code generation
    pub fn add_fixture(&mut self, name: &str, has_teardown: bool, dependencies: Vec<String>) {
        self.fixtures.insert(name.to_string(), (has_teardown, dependencies));
    }

    /// Enable test mode (emit #[test] attributes)
    pub fn set_test_mode(&mut self, enabled: bool) {
        self.test_mode = enabled;
    }

    /// Set specific test function to mark with #[test]
    pub fn set_test_function(&mut self, name: &str) {
        self.test_function = Some(name.to_string());
    }

    /// Check if serde is needed
    pub fn needs_serde(&self) -> bool {
        self.needs_serde
    }

    /// Check if tokio is needed
    pub fn needs_tokio(&self) -> bool {
        self.needs_tokio
    }

    /// Check if axum is needed
    pub fn needs_axum(&self) -> bool {
        self.needs_axum
    }

    /// Add a dependency module (for multi-file compilation)
    pub fn add_module(&mut self, _module_name: &str, module_ast: &'a Program) {
        self.dependency_modules.push(module_ast);
    }

    /// Generate Rust code for a dependency module (not the main module)
    ///
    /// This emits only the module's declarations with appropriate visibility,
    /// without the prelude or main function handling. The output is suitable
    /// for writing to a separate `.rs` file.
    ///
    /// # Arguments
    /// * `module_name` - Name of the module (used for comments)
    /// * `program` - The parsed AST of the module
    ///
    /// # Returns
    /// Generated Rust code for the module
    pub fn generate_module(&mut self, module_name: &str, program: &Program) -> String {
        // Use a fresh emitter for this module
        let mut emitter = RustEmitter::new();
        
        // Add module header comment
        emitter.comment(&format!("Module: {}", module_name));
        emitter.comment("Generated by the Incan compiler");
        emitter.blank_line();
        
        // Scan for serde needs in this module
        self.scan_for_serde(program);
        
        // Emit serde import if needed by this module
        if self.needs_serde {
            emitter.use_stmt("serde::{Serialize, Deserialize}");
            emitter.blank_line();
        }
        
        // Emit all declarations (skipping imports and docstrings)
        for decl in &program.declarations {
            match &decl.node {
                Declaration::Import(_) | Declaration::Docstring(_) => {
                    // Skip imports (handled by main.rs) and docstrings
                }
                _ => {
                    // Emit declaration using the module's emitter
                    // We need to temporarily swap emitters
                    let main_emitter = std::mem::replace(&mut self.emitter, emitter);
                    self.emit_declaration(decl);
                    self.emitter.blank_line();
                    emitter = std::mem::replace(&mut self.emitter, main_emitter);
                }
            }
        }
        
        emitter.finish()
    }

    /// Generate Rust code from an Incan program (single-file mode, inlines dependencies)
    pub fn generate(mut self, program: &'a Program) -> String {
        self.current_program = Some(program);

        // Scan for serde usage before emitting prelude
        self.scan_for_serde(program);
        for dep in &self.dependency_modules.clone() {
            self.scan_for_serde(dep);
        }

        // Scan for async usage before emitting prelude
        self.scan_for_async(program);
        for dep in &self.dependency_modules.clone() {
            self.scan_for_async(dep);
        }

        // Scan for web framework usage before emitting prelude
        self.scan_for_web(program);
        for dep in &self.dependency_modules.clone() {
            self.scan_for_web(dep);
        }

        // Collect routes from @route decorators
        self.collect_routes(program);
        for dep in &self.dependency_modules.clone() {
            self.collect_routes(dep);
        }

        // Add prelude/imports
        self.emit_prelude();

        // Collect all declarations to emit (from deps and main)
        let mut all_decls: Vec<&Spanned<Declaration>> = Vec::new();

        // First, collect declarations from all dependency modules
        for dep in &self.dependency_modules {
            for decl in &dep.declarations {
                match &decl.node {
                    Declaration::Import(_) | Declaration::Docstring(_) => {
                        // Skip imports and docstrings from dependencies
                    }
                    _ => {
                        all_decls.push(decl);
                    }
                }
            }
        }

        // Then add main module's declarations
        for decl in &program.declarations {
            all_decls.push(decl);
        }

        // Now emit all collected declarations
        for decl in all_decls {
            self.emit_declaration(decl);
            self.emitter.blank_line();
        }

        self.emitter.finish()
    }

    /// Generate Rust code for a multi-file project
    ///
    /// Returns a tuple of (main_code, modules) where:
    /// - main_code: The main.rs content (without mod declarations - those are added by ProjectGenerator)
    /// - modules: HashMap of module_name -> module_code for each dependency
    ///
    /// # Arguments
    /// * `program` - The main module's AST
    /// * `module_names` - Names of the dependency modules (in order matching dependency_modules)
    pub fn generate_multi_file(mut self, program: &'a Program, module_names: &[&str]) -> (String, HashMap<String, String>) {
        self.current_program = Some(program);

        // Scan all modules for features
        self.scan_for_serde(program);
        self.scan_for_async(program);
        self.scan_for_web(program);
        self.collect_routes(program);
        
        for dep in &self.dependency_modules.clone() {
            self.scan_for_serde(dep);
            self.scan_for_async(dep);
            self.scan_for_web(dep);
            self.collect_routes(dep);
        }

        // Generate code for each dependency module
        let mut modules = HashMap::new();
        for (i, dep) in self.dependency_modules.clone().iter().enumerate() {
            let module_name = module_names.get(i).copied().unwrap_or("module");
            let module_code = self.generate_module(module_name, dep);
            modules.insert(module_name.to_string(), module_code);
        }

        // Generate main module code (without dependency declarations)
        self.emit_prelude();
        
        // Emit only the main module's declarations
        for decl in &program.declarations {
            self.emit_declaration(decl);
            self.emitter.blank_line();
        }

        let main_code = self.emitter.finish();
        (main_code, modules)
    }

    /// Generate Rust code for a multi-file project with nested module paths.
    ///
    /// Returns a tuple of:
    /// - main_code: The main.rs content (without mod declarations - those are added by ProjectGenerator)
    /// - modules: HashMap of path_segments -> module_code for each dependency
    ///
    /// # Arguments
    /// * `program` - The main module's AST
    /// * `module_paths` - Path segments for each dependency module (in order matching dependency_modules)
    pub fn generate_multi_file_nested(mut self, program: &'a Program, module_paths: &[Vec<String>]) -> (String, HashMap<Vec<String>, String>) {
        self.current_program = Some(program);

        // Scan all modules for features
        self.scan_for_serde(program);
        self.scan_for_async(program);
        self.scan_for_web(program);
        self.collect_routes(program);
        
        for dep in &self.dependency_modules.clone() {
            self.scan_for_serde(dep);
            self.scan_for_async(dep);
            self.scan_for_web(dep);
            self.collect_routes(dep);
        }

        // Generate code for each dependency module
        let mut modules = HashMap::new();
        for (i, dep) in self.dependency_modules.clone().iter().enumerate() {
            let path_segments = module_paths.get(i).cloned().unwrap_or_else(|| vec!["module".to_string()]);
            let module_name = path_segments.join("_");
            let module_code = self.generate_module(&module_name, dep);
            modules.insert(path_segments, module_code);
        }

        // Generate main module code (without dependency declarations)
        self.emit_prelude();
        
        // Emit only the main module's declarations
        for decl in &program.declarations {
            self.emit_declaration(decl);
            self.emitter.blank_line();
        }

        let main_code = self.emitter.finish();
        (main_code, modules)
    }

    /// Scan a program for Serialize/Deserialize derives
    pub fn scan_for_serde(&mut self, program: &Program) {
        for decl in &program.declarations {
            let decorators = match &decl.node {
                Declaration::Model(m) => &m.decorators,
                Declaration::Class(c) => &c.decorators,
                _ => continue,
            };

            for dec in decorators {
                if dec.node.name == "derive" {
                    for arg in &dec.node.args {
                        if let DecoratorArg::Positional(expr) = arg {
                            if let Expr::Ident(name) = &expr.node {
                                if name == "Serialize" || name == "Deserialize" {
                                    self.needs_serde = true;
                                    return;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /// Scan a program for async usage
    pub fn scan_for_async(&mut self, program: &Program) {
        for decl in &program.declarations {
            match &decl.node {
                Declaration::Function(func) => {
                    if func.is_async {
                        self.needs_tokio = true;
                        return;
                    }
                    if self.body_uses_async(&func.body) {
                        self.needs_tokio = true;
                        return;
                    }
                }
                Declaration::Model(model) => {
                    for method in &model.methods {
                        if method.node.is_async {
                            self.needs_tokio = true;
                            return;
                        }
                        if let Some(body) = &method.node.body {
                            if self.body_uses_async(body) {
                                self.needs_tokio = true;
                                return;
                            }
                        }
                    }
                }
                Declaration::Class(class) => {
                    for method in &class.methods {
                        if method.node.is_async {
                            self.needs_tokio = true;
                            return;
                        }
                        if let Some(body) = &method.node.body {
                            if self.body_uses_async(body) {
                                self.needs_tokio = true;
                                return;
                            }
                        }
                    }
                }
                _ => {}
            }
        }
    }

    /// Check if a function body uses async features
    fn body_uses_async(&self, body: &[Spanned<Statement>]) -> bool {
        for stmt in body {
            if self.stmt_uses_async(&stmt.node) {
                return true;
            }
        }
        false
    }

    /// Check if a statement uses async features
    fn stmt_uses_async(&self, stmt: &Statement) -> bool {
        match stmt {
            Statement::Expr(expr) => self.expr_uses_async(&expr.node),
            Statement::Assignment(assign) => self.expr_uses_async(&assign.value.node),
            Statement::CompoundAssignment(assign) => self.expr_uses_async(&assign.value.node),
            Statement::FieldAssignment(assign) => self.expr_uses_async(&assign.value.node),
            Statement::IndexAssignment(assign) => self.expr_uses_async(&assign.value.node),
            Statement::TupleUnpack(unpack) => self.expr_uses_async(&unpack.value.node),
            Statement::Return(Some(expr)) => self.expr_uses_async(&expr.node),
            Statement::If(if_stmt) => {
                self.expr_uses_async(&if_stmt.condition.node)
                    || self.body_uses_async(&if_stmt.then_body)
                    || if_stmt.else_body.as_ref().map_or(false, |b| self.body_uses_async(b))
            }
            Statement::While(while_stmt) => {
                self.expr_uses_async(&while_stmt.condition.node) || self.body_uses_async(&while_stmt.body)
            }
            Statement::For(for_stmt) => {
                self.expr_uses_async(&for_stmt.iter.node) || self.body_uses_async(&for_stmt.body)
            }
            _ => false,
        }
    }

    /// Check if an expression uses async features
    fn expr_uses_async(&self, expr: &Expr) -> bool {
        match expr {
            Expr::Await(_) => true,
            Expr::Call(function, args) => {
                if let Expr::Ident(name) = &function.node {
                    if matches!(name.as_str(), "spawn" | "sleep" | "timeout" | "channel" | "unbounded_channel") {
                        return true;
                    }
                }
                self.expr_uses_async(&function.node)
                    || args.iter().any(|arg| self.call_arg_uses_async(arg))
            }
            Expr::Binary(left, _, right) => {
                self.expr_uses_async(&left.node) || self.expr_uses_async(&right.node)
            }
            Expr::Unary(_, expr) => self.expr_uses_async(&expr.node),
            Expr::MethodCall(receiver, _, args) => {
                self.expr_uses_async(&receiver.node)
                    || args.iter().any(|arg| self.call_arg_uses_async(arg))
            }
            Expr::Field(base, _) => self.expr_uses_async(&base.node),
            Expr::Index(base, index) => {
                self.expr_uses_async(&base.node) || self.expr_uses_async(&index.node)
            }
            Expr::Slice(base, _) => self.expr_uses_async(&base.node),
            Expr::If(if_expr) => {
                self.expr_uses_async(&if_expr.condition.node)
                    || self.body_uses_async(&if_expr.then_body)
                    || if_expr.else_body.as_ref().map_or(false, |b| self.body_uses_async(b))
            }
            Expr::Match(expr, arms) => {
                self.expr_uses_async(&expr.node)
                    || arms.iter().any(|arm| self.match_body_uses_async(&arm.node.body))
            }
            Expr::Closure(_, body) => self.expr_uses_async(&body.node),
            Expr::List(items) | Expr::Tuple(items) | Expr::Set(items) => {
                items.iter().any(|item| self.expr_uses_async(&item.node))
            }
            Expr::Dict(pairs) => {
                pairs.iter().any(|(k, v)| self.expr_uses_async(&k.node) || self.expr_uses_async(&v.node))
            }
            Expr::FString(parts) => {
                parts.iter().any(|part| {
                    if let FStringPart::Expr(expr) = part {
                        self.expr_uses_async(&expr.node)
                    } else {
                        false
                    }
                })
            }
            Expr::ListComp(comp) => {
                self.expr_uses_async(&comp.expr.node)
                    || self.expr_uses_async(&comp.iter.node)
                    || comp.filter.as_ref().map_or(false, |c| self.expr_uses_async(&c.node))
            }
            Expr::DictComp(comp) => {
                self.expr_uses_async(&comp.key.node)
                    || self.expr_uses_async(&comp.value.node)
                    || self.expr_uses_async(&comp.iter.node)
                    || comp.filter.as_ref().map_or(false, |c| self.expr_uses_async(&c.node))
            }
            Expr::Constructor(_, args) => {
                args.iter().any(|arg| self.call_arg_uses_async(arg))
            }
            Expr::Try(inner) => self.expr_uses_async(&inner.node),
            Expr::Paren(inner) => self.expr_uses_async(&inner.node),
            _ => false,
        }
    }

    /// Check if a call argument uses async
    fn call_arg_uses_async(&self, arg: &CallArg) -> bool {
        match arg {
            CallArg::Positional(expr) => self.expr_uses_async(&expr.node),
            CallArg::Named(_, expr) => self.expr_uses_async(&expr.node),
        }
    }

    /// Check if a match body uses async
    fn match_body_uses_async(&self, body: &MatchBody) -> bool {
        match body {
            MatchBody::Expr(expr) => self.expr_uses_async(&expr.node),
            MatchBody::Block(stmts) => self.body_uses_async(stmts),
        }
    }

    /// Scan a program for web framework usage
    pub fn scan_for_web(&mut self, program: &Program) {
        for decl in &program.declarations {
            match &decl.node {
                Declaration::Import(import) => {
                    match &import.kind {
                        ImportKind::Module(path) if !path.segments.is_empty() => {
                            if path.segments[0] == "web" {
                                self.needs_axum = true;
                                self.needs_tokio = true;
                                self.needs_serde = true;
                                return;
                            }
                        }
                        ImportKind::From { module, .. } if !module.segments.is_empty() => {
                            if module.segments[0] == "web" {
                                self.needs_axum = true;
                                self.needs_tokio = true;
                                self.needs_serde = true;
                                return;
                            }
                        }
                        _ => {}
                    }
                }
                Declaration::Function(func) => {
                    for dec in &func.decorators {
                        if dec.node.name == "route" {
                            self.needs_axum = true;
                            self.needs_tokio = true;
                            self.needs_serde = true;
                            return;
                        }
                    }
                }
                _ => {}
            }
        }
    }

    /// Collect routes from @route decorators
    fn collect_routes(&mut self, program: &Program) {
        for decl in &program.declarations {
            if let Declaration::Function(func) = &decl.node {
                for dec in &func.decorators {
                    if dec.node.name == "route" {
                        let mut path = String::new();
                        let mut methods = vec!["GET".to_string()];

                        for arg in &dec.node.args {
                            match arg {
                                DecoratorArg::Positional(expr) => {
                                    if path.is_empty() {
                                        if let Expr::Literal(Literal::String(s)) = &expr.node {
                                            path = s.clone();
                                        }
                                    }
                                }
                                DecoratorArg::Named(name, value) => {
                                    if name == "methods" {
                                        if let DecoratorArgValue::Expr(expr) = value {
                                            if let Expr::List(items) = &expr.node {
                                                methods = items.iter().filter_map(|item| {
                                                    if let Expr::Literal(Literal::String(s)) = &item.node {
                                                        Some(s.clone())
                                                    } else {
                                                        None
                                                    }
                                                }).collect();
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        if !path.is_empty() {
                            self.routes.push(RouteInfo {
                                handler_name: func.name.clone(),
                                path,
                                methods,
                                is_async: func.is_async,
                            });
                        }
                    }
                }
            }
        }
    }
}

impl Default for RustCodegen<'_> {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::frontend::{lexer, parser};

    fn generate(source: &str) -> String {
        let tokens = lexer::lex(source).unwrap();
        let ast = parser::parse(&tokens).unwrap();
        RustCodegen::new().generate(&ast)
    }

    #[test]
    fn test_simple_function() {
        let code = generate(r#"
def add(a: int, b: int) -> int:
  return a + b
"#);
        assert!(code.contains("fn add(a: i64, b: i64) -> i64"));
        assert!(code.contains("(a + b)"));
    }

    #[test]
    fn test_model_generation() {
        let code = generate(r#"
model User:
  name: str
  age: int
"#);
        assert!(code.contains("pub struct User"));
        assert!(code.contains("pub name: String"));
        assert!(code.contains("pub age: i64"));
    }

    #[test]
    fn test_println_multiple_args() {
        let code = generate(r#"
def main() -> None:
  println("hello", "world", 42)
"#);
        assert!(code.contains("println!(\"{} {} {}\""));
    }

    #[test]
    fn test_println_single_arg() {
        let code = generate(r#"
def main() -> None:
  println("hello")
"#);
        assert!(code.contains("println!"));
    }

    #[test]
    fn test_web_run_uses_dynamic_host_and_port() {
        let code = generate(r#"
from web import App, route, Response

@route("/ping")
async def ping() -> Response:
  return Response.ok()

def main() -> None:
  config_host = "0.0.0.0"
  config_port = 3001
  app = App()
  app.run(host=config_host, port=config_port)
"#);

        // Host/port should be emitted from expressions, not baked as defaults
        assert!(code.contains("let host: String"));
        assert!(code.contains("config_host"));
        assert!(code.contains("let port: u16"));
        assert!(code.contains("config_port"));
        assert!(code.contains("format!(\"{}:{}\", host, port)"));
        assert!(code.contains(".parse()"));
        assert!(code.contains("invalid host/port combination for binding"));
    }

    #[test]
    fn test_class_method_emission() {
        let code = generate(r#"
class Greeter:
  def greet(self, name: str) -> str:
    return f"Hello {name}"
"#);

        assert!(code.contains("impl Greeter"));
        assert!(code.contains("pub fn greet(&self, name: String) -> String"));
        assert!(code.contains("format!(\"Hello {}\", name)"));
    }

    #[test]
    fn test_async_trait_method_signature() {
        let code = generate(r#"
trait Logger:
  async def log(self, msg: str) -> Unit:
    pass
"#);

        assert!(code.contains("trait Logger"));
        assert!(code.contains("async fn log(&self, msg: String) -> ()"));
    }

    #[test]
    fn test_generate_module() {
        let source = r#"
model User:
  name: str
  age: int

def create_user(name: str) -> User:
  return User(name=name, age=0)
"#;
        let tokens = lexer::lex(source).unwrap();
        let ast = parser::parse(&tokens).unwrap();
        let mut codegen = RustCodegen::new();
        let code = codegen.generate_module("models", &ast);
        
        // Check module header
        assert!(code.contains("Module: models"));
        assert!(code.contains("Generated by the Incan compiler"));
        
        // Check struct is public
        assert!(code.contains("pub struct User"));
        
        // Check function is public
        assert!(code.contains("pub fn create_user"));
    }

    #[test]
    fn test_generate_module_skips_imports() {
        let source = r#"
from something import Other

model User:
  name: str
"#;
        let tokens = lexer::lex(source).unwrap();
        let ast = parser::parse(&tokens).unwrap();
        let mut codegen = RustCodegen::new();
        let code = codegen.generate_module("models", &ast);
        
        // Should NOT contain use statements for Incan imports
        assert!(!code.contains("use something"));
        
        // Should contain the model
        assert!(code.contains("pub struct User"));
    }

    #[test]
    fn test_generate_multi_file() {
        // Create main module
        let main_source = r#"
from models import User

def main() -> None:
  user = User(name="Alice")
  println(user.name)
"#;
        let main_tokens = lexer::lex(main_source).unwrap();
        let main_ast = parser::parse(&main_tokens).unwrap();

        // Create dependency module
        let models_source = r#"
model User:
  name: str
"#;
        let models_tokens = lexer::lex(models_source).unwrap();
        let models_ast = parser::parse(&models_tokens).unwrap();

        // Generate multi-file output
        let mut codegen = RustCodegen::new();
        codegen.add_module("models", &models_ast);
        let (main_code, modules) = codegen.generate_multi_file(&main_ast, &["models"]);

        // Check main code
        assert!(main_code.contains("fn main()"));
        assert!(main_code.contains("use models::User;"));
        // Main should NOT contain the User struct (it's in the module)
        assert!(!main_code.contains("pub struct User"));

        // Check modules
        assert!(modules.contains_key("models"));
        let models_code = &modules["models"];
        assert!(models_code.contains("pub struct User"));
        assert!(models_code.contains("Module: models"));
    }
}
