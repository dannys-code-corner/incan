"""
Models vs Classes in Incan

Incan has TWO ways to define types with fields:
- `model` — data-first (like Python dataclass, Pydantic BaseModel)
- `class` — behavior-first (traditional OOP class)

Why no `struct`?
- Python developers know `class`, not `struct`
- `model` clearly signals "this is data"
- Both compile to Rust structs under the hood

When to use which:
┌─────────────────────────────────────┬─────────┐
│ Use Case                            │ Choose  │
├─────────────────────────────────────┼─────────┤
│ Config, DTO, API payload, record    │ model   │
│ Service with methods, stateful obj  │ class   │
│ Data + validation                   │ model   │
│ Inheritance needed                  │ class   │
└─────────────────────────────────────┴─────────┘

Key differences:
- model: Cannot inherit, focused on fields
- class: Can inherit (extends), can have complex methods
- Both: Can implement traits (with)
"""


# ============================================
# MODEL: Data-first — fields are the primary concern
# ============================================

# Simple data container — like a Python dataclass
model Point:
    x: int
    y: int


# Model with derived behaviors
@derive(Eq, Serialize, Deserialize)
model User:
    id: int
    name: str
    email: str


# Model representing API response
@derive(Serialize)
model ApiResponse:
    success: bool
    message: str
    data: Option[str]


# ============================================
# CLASS: Behavior-first — methods are the primary concern
# ============================================

# Trait that classes can implement
trait Describable:
    def describe(self) -> str: ...


# Class with behavior and trait implementation
class Animal with Describable:
    name: str
    age: int

    def describe(self) -> str:
        return f"{self.name} is {self.age} years old"

    def have_birthday(mut self) -> None:
        self.age = self.age + 1


# Class that uses inheritance (extends Animal)
class Pet extends Animal:
    species: str
    owner: str

    # Override parent's describe method
    def describe(self) -> str:
        return f"{self.name} the {self.species}, owned by {self.owner}"

    def rename(mut self, new_name: str) -> None:
        self.name = new_name


# ============================================
# COMPARISON IN ACTION
# ============================================

def main() -> None:
    println("=== Models vs Classes Demo ===")
    println("")

    # --- Models: Simple data containers ---
    println("--- Models (data-first) ---")
    
    point = Point(x=10, y=20)
    println(f"Point: ({point.x}, {point.y})")
    
    user = User(id=1, name="Alice", email="alice@example.com")
    println(f"User: {user.name} <{user.email}>")
    
    response = ApiResponse(success=true, message="OK", data=Some("payload"))
    println(f"Response: success={response.success}")
    
    println("")

    # --- Classes: Objects with behavior ---
    println("--- Classes (behavior-first) ---")
    
    mut animal = Animal(name="Buddy", age=3)
    println(animal.describe())
    animal.have_birthday()
    println(f"After birthday: {animal.describe()}")
    
    println("")
    
    mut pet = Pet(name="Whiskers", age=2, species="cat", owner="Bob")
    println(pet.describe())
    new_name: str = "Fluffy"
    pet.rename(new_name)
    println(f"After rename: {pet.describe()}")

    println("")
    println("=== Key Insight ===")
    println("Use `model` for data, `class` for behavior.")
    println("Both compile to efficient Rust structs!")
