"""
Newtypes in Incan

This example demonstrates:
- Creating type-safe wrappers with newtype
- Using newtypes for validation (like Email, UserId)
- Preventing accidental type mixing
- Validated constructors (return Result)

Unlike type aliases, newtypes create distinct types at compile time.
This prevents accidentally mixing up values that have the same 
underlying type (e.g., user_id and product_id are both int).

Rust equivalent:
```rust
struct UserId(i64);
struct ProductId(i64);
struct Email(String);
```
"""

type UserId = newtype int
type ProductId = newtype int
type Email = newtype str:
    def from_underlying(v: str) -> Result[Email, str]:
        if "@" not in v:
            return Err("missing @")
        return Ok(Email(v.lower()))


def get_user_name(user_id: UserId) -> str:
    return f"Name of user {user_id.0}"


def get_product_name(product_id: ProductId) -> str:
    return f"Widget {product_id.0}"


def make_positive_id(n: int) -> Result[UserId, str]:
    if n > 0:
        return Ok(UserId(n))
    return Err("ID must be positive")


def main() -> None:
    user_id = UserId(42)
    product_id = ProductId(100)
    # Checked construction (v0.1 runway): since Email defines from_underlying,
    # calling Email(...) validates and panics on invalid input.
    email = Email("alice@example.com")
    user_id_val = user_id.0
    product_id_val = product_id.0
    email_str = email.0
    user_name = get_user_name(user_id)
    product_name = get_product_name(product_id)
    println(f"User {user_id_val}: {user_name}")
    println(f"Product {product_id_val}: {product_name}")
    println(f"Email: {email_str}")
    result = make_positive_id(5)

    match result:
        Ok(valid_id) => println(f"Created valid ID: {valid_id.0}")
        Err(msg) => println(f"Error: {msg}")
