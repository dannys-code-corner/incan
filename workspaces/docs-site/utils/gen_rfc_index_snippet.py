from __future__ import annotations

import re
from pathlib import Path

import mkdocs_gen_files
from mkdocs.exceptions import ConfigurationError

DOCS_DIR = Path(__file__).resolve().parents[1] / "docs"
RFC_DIR = DOCS_DIR / "RFCs"
CLOSED_DIR = RFC_DIR / "closed"
IMPLEMENTED_DIR = CLOSED_DIR / "implemented"
SUPERSEDED_DIR = CLOSED_DIR / "superseded"
REJECTED_DIR = CLOSED_DIR / "rejected"


def _first_h1_title(md_path: Path) -> str:
    """Get the first H1 title from a markdown file."""
    text = md_path.read_text(encoding="utf-8", errors="replace")
    for line in text.splitlines():
        m = re.match(r"^#\s+(.+?)\s*$", line)
        if m:
            return m.group(1).strip()
    return md_path.stem


def _rfc_id_from_filename(filename: str) -> str:
    """extract the RFC id from a filename
    "013_rust_crate_dependencies.md" -> "013"
    """
    m = re.match(r"^(\d+)", filename)
    return m.group(1) if m else filename


def _escape_pipes(s: str) -> str:
    """Keep markdown tables valid by escaping pipes."""
    return s.replace("|", "\\|")

def _extract_status(md_path: Path) -> str:
    """
    Extract RFC status from the RFC file.

    Expected patterns:
    - "**Status:** Draft"
    - "- Status: Draft"
    """
    text = md_path.read_text(encoding="utf-8", errors="replace")
    for line in text.splitlines():
        m = re.match(r"^\s*\*\*Status:\*\*\s*(.+?)\s*$", line)
        if m:
            return m.group(1).strip()
        m = re.match(r"^\s*-\s*Status:\s*(.+?)\s*$", line)
        if m:
            return m.group(1).strip()
    return "Unknown"

def _strip_rfc_prefix(title: str, rfc_id: str) -> str:
    """Convert titles like 'RFC 001: Test Fixtures' to 'Test Fixtures' for display."""
    title = title.strip()
    m = re.match(rf"^RFC\s+{re.escape(rfc_id)}\s*:\s*(.+)$", title, flags=re.IGNORECASE)
    return m.group(1).strip() if m else title


def _sorted_md_files(dir_path: Path) -> list[Path]:
    """Sort markdown files in a directory numerically (by their name)."""
    if not dir_path.exists():
        return []
    files = [
        p
        for p in dir_path.glob("*.md")
        if p.is_file() and p.name.lower() != "index.md"
    ]
    # Stable numeric-ish ordering: filenames are zero-padded.
    return sorted(files, key=lambda p: p.name)


def _collect_rows() -> list[tuple[str, str, str, str, str]]:
    """Collect RFCs and return rows: (rfc_id, title, status, track, url)."""
    rows: list[tuple[str, str, str, str, str]] = []

    # Closed RFCs first (still sorted); status is read from the file, while track is inferred from location.
    for p in _sorted_md_files(IMPLEMENTED_DIR):
        rfc_id = _rfc_id_from_filename(p.name)
        title = _strip_rfc_prefix(_first_h1_title(p), rfc_id)
        # For closed RFCs, infer status from location to keep the index "at a glance"
        # even if the RFC text reflects its historical status.
        status = "Done"
        track = "closed / implemented"
        url = f"/RFCs/closed/implemented/{p.stem}/"
        rows.append((rfc_id, title, status, track, url))

    for p in _sorted_md_files(SUPERSEDED_DIR):
        rfc_id = _rfc_id_from_filename(p.name)
        title = _strip_rfc_prefix(_first_h1_title(p), rfc_id)
        status = "Superseded"
        track = "closed / superseded"
        url = f"/RFCs/closed/superseded/{p.stem}/"
        rows.append((rfc_id, title, status, track, url))

    for p in _sorted_md_files(REJECTED_DIR):
        rfc_id = _rfc_id_from_filename(p.name)
        title = _strip_rfc_prefix(_first_h1_title(p), rfc_id)
        status = "Rejected"
        track = "closed / rejected"
        url = f"/RFCs/closed/rejected/{p.stem}/"
        rows.append((rfc_id, title, status, track, url))

    for p in _sorted_md_files(RFC_DIR):
        if p.name in {"index.md", "TEMPLATE.md"}:
            continue
        rfc_id = _rfc_id_from_filename(p.name)
        title = _strip_rfc_prefix(_first_h1_title(p), rfc_id)
        status = _extract_status(p)
        track = "proposed / active"
        url = f"/RFCs/{p.stem}/"
        rows.append((rfc_id, title, status, track, url))

    # Sort by RFC id (string numeric sort works because ids are zero-padded)
    rows.sort(key=lambda r: r[0])
    return rows


def _render_reference_links(rows: list[tuple[str, str, str, str, str]]) -> str:
    """Render reference-style RFC links for reuse across docs pages."""
    lines: list[str] = []
    lines.append("<!-- THIS FILE IS AUTOGENERATED. DO NOT EDIT BY HAND. -->")
    lines.append("")
    lines.append("<!-- RFC reference links for reuse: '[RFC 018]' or '[RFC 018: Title][RFC 018]' -->")
    for rfc_id, _title, _status, _track, url in rows:
        lines.append(f"[RFC {rfc_id}]: {url}")
    lines.append("")
    return "\n".join(lines)


def _render_table(rows: list[tuple[str, str, str, str, str]]) -> str:
    """Render the RFCs index table."""
    RFC_WIDTH = 9
    STATUS_WIDTH = 11
    TRACK_WIDTH = 17
    TITLE_WIDTH = 120 - (2 + RFC_WIDTH + 3 + STATUS_WIDTH + 3 + TRACK_WIDTH + 3 + 2)

    lines: list[str] = []
    lines.append("<!-- THIS FILE IS AUTOGENERATED. DO NOT EDIT BY HAND. -->")
    lines.append("")
    lines.append("<!-- markdownlint-disable MD013 MD060 MD053 MD033 -->")

    lines.append("<!-- Reference links for reuse (e.g. ROADMAP '[RFC 000]') -->")
    for rfc_id, _title, _status, _track, url in rows:
        lines.append(f"[RFC {rfc_id}]: {url}")
    lines.append("")

    lines.append("<!-- RFCs index table -->")
    lines.append("")
    lines.append("<!-- RFC index filter UI -->")
    lines.append("")
    lines.append('<div class="rfc-index-filter">')
    lines.append('  <label>')
    lines.append('    Filter RFCs: <input type="search" data-rfc-filter="rfcs-index" placeholder="e.g. 018, testing, superseded">')
    lines.append('  </label>')
    lines.append('  <p><small>Tip: press <code>Esc</code> to clear.</small></p>')
    lines.append("</div>")
    lines.append("")
    # NOTE: Markdown tables are not parsed inside raw HTML blocks unless explicitly enabled.
    # `md_in_html` is enabled in mkdocs.yml, so `markdown="1"` ensures the table renders correctly.
    lines.append('<div data-rfc-table="rfcs-index" markdown="1">')
    lines.append("")
    lines.append(f"| {'RFC':<{RFC_WIDTH}} | {'Status':<{STATUS_WIDTH}} | {'Track':<{TRACK_WIDTH}} | {'Title':<{TITLE_WIDTH}} |")
    lines.append(f"| {'':-<{RFC_WIDTH-1}}: | {'':-<{STATUS_WIDTH}} | {'':-<{TRACK_WIDTH}} | {'':-<{TITLE_WIDTH}} |")
    for rfc_id, title, status, track, url in rows:
        safe_title = _escape_pipes(title)
        safe_status = _escape_pipes(status)
        safe_track = _escape_pipes(track)
        lines.append(f"| {'[RFC ' + rfc_id + ']':<{RFC_WIDTH}} | {safe_status:<{STATUS_WIDTH}} | {safe_track:<{TRACK_WIDTH}} | {safe_title:<{TITLE_WIDTH}} |")
    lines.append("")
    lines.append("</div>")
    lines.append("<!-- markdownlint-enable MD013 MD060 MD053 MD033 -->")

    return "\n".join(lines)

def main() -> None:
    """Main entry point for generating the RFCs index snippet."""
    rows = _collect_rows()
    content = _render_table(rows)
    refs = _render_reference_links(rows)

    # We want two things:
    # 1) The file to exist on disk so `pymdownx.snippets` can include it via `--8<--`.
    # 2) The file to also exist in MkDocs' virtual file set for completeness.
    rel_path = "_snippets/tables/rfcs_index.md"
    refs_rel_path = "_snippets/rfcs_refs.md"

    # (1) physical file on disk
    (DOCS_DIR / "_snippets" / "tables").mkdir(parents=True, exist_ok=True)
    (DOCS_DIR / rel_path).write_text(content, encoding="utf-8")
    (DOCS_DIR / refs_rel_path).write_text(refs, encoding="utf-8")

    # (2) virtual file for mkdocs (gen-files)
    try:
        with mkdocs_gen_files.open(rel_path, "w") as f:
            f.write(content)
        with mkdocs_gen_files.open(refs_rel_path, "w") as f:
            f.write(refs)
    except ConfigurationError:
        # Allow running this script directly from repo root where mkdocs.yml
        # doesn't exist (it's under workspaces/docs-site/).
        pass


if __name__ == "__main__":
    main()
