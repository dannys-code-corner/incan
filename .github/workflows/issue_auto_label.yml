name: Auto-label issues and PRs (sync)

on:
  issues:
    types: [opened, edited]
  pull_request:
    types: [opened, edited, reopened, synchronize, ready_for_review]
  pull_request_target:
    types: [opened, edited, reopened, synchronize, ready_for_review]

permissions:
  issues: write

jobs:
  label:
    runs-on: ubuntu-latest
    steps:
      - name: Dump event payload (debug)
        run: cat "$GITHUB_EVENT_PATH"
      - uses: actions/github-script@v7
        with:
          script: |
            const isPR = context.eventName === "pull_request_target";
            const payload = context.payload;

            const body = isPR ? (payload.pull_request?.body ?? "") : (payload.issue?.body ?? "");

            // Only manage these labels; never remove unrelated labels (bug/feature/etc).
            const managed = new Set([
              "incan language semantics",
              "incan compiler",
              "tooling",
              "editor integration",
              "runtime / core crates",
              "documentation",
            ]);

            // Map template "Area" option strings -> labels.
            // IMPORTANT: these option strings must match the templates exactly.
            const optionToLabel = new Map([
              ["Incan Language (syntax/semantics)", "incan language semantics"],
              ["Compiler (frontend/backend/codegen)", "incan compiler"],
              ["Tooling (CLI/formatter/test runner)", "tooling"],
              ["Editor integration (LSP/VS Code extension)", "editor integration"],
              ["Runtime / Core crates (stdlib/core/derive)", "runtime / core crates"],
              ["Documentation", "documentation"],
            ]);

            // Extract a section from a markdown string based on a heading.
            function extractSection(markdown, heading) {
              // Escape special regex characters in the heading.
              const esc = heading.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
              // Create a regular expression to match the heading.
              const re = new RegExp(`^\\s*#{2,6}\\s+${esc}\\s*$`, "mi");
              // Execute the regular expression on the markdown string.
              const m = re.exec(markdown);
              // If no match, return an empty string.
              if (!m) return "";
              // Get the start index of the match.
              const start = m.index + m[0].length;
              // Get the rest of the markdown string after the match.
              const rest = markdown.slice(start);
              const next = rest.search(/^\\s*#{2,6}\\s+/m);
              return (next === -1 ? rest : rest.slice(0, next)).trim();
            }

            // Issue forms render the dropdown under "### Area"; PR template uses "## Area(s)".
            let areaBlock = extractSection(body, isPR ? "Area(s)" : "Area");
            if (!areaBlock) {
              areaBlock = extractSection(body, "Area");
            }

            const desired = new Set();

            if (isPR) {
              // PR template uses checkboxes; only apply labels for checked items.
              const checkedLines = areaBlock
                .split("\n")
                .map((l) => l.trim())
                .filter((l) => /^[-*]\s*\[[xX]\]\s+/.test(l));

              // For each option, add the corresponding label to the set.
              for (const [opt, label] of optionToLabel.entries()) {
                if (checkedLines.some((l) => l.includes(opt))) desired.add(label);
              }

              // Log the preview of the area block, the checked lines, and the desired labels.
              console.log({ isPR, areaBlockPreview: areaBlock.slice(0, 300), checkedLines, desired: [...desired] });
            } else {
              // Issue forms render selected options as plain text in the section.
              for (const [opt, label] of optionToLabel.entries()) {
                if (areaBlock.includes(opt)) desired.add(label);
              }
            }

            // If user picked "Other" or the section is missing, don't touch labels.
            if (desired.size === 0) return;

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = isPR ? payload.pull_request.number : context.issue.number;

            // Current labels on the issue/PR
            const current = new Set(
              (isPR ? payload.pull_request.labels : payload.issue.labels ?? []).map((l) => l.name)
            );

            // Compute label changes
            const toAdd = [...desired].filter(l => !current.has(l));
            const toRemove = [...current].filter(l => managed.has(l) && !desired.has(l));

            if (toAdd.length > 0) {
              await github.rest.issues.addLabels({ owner, repo, issue_number, labels: toAdd });
            }

            for (const label of toRemove) {
              try {
                await github.rest.issues.removeLabel({ owner, repo, issue_number, name: label });
              } catch (e) {
                // If the label was removed concurrently or doesn't exist, ignore.
                if (e?.status !== 404) throw e;
              }
            }

            // -------------------------------------------------------------------------------------
            // Issue Type sync (native GitHub issue type, NOT labels)
            // -------------------------------------------------------------------------------------
            // We deliberately do not infer type from labels. Instead, we map from the title prefix that issue forms
            // prefill (bug/feature/chore).
            //
            // Notes:
            // - Only applies to issues (not PRs).
            // - If the GraphQL schema doesn't support issueType for this repo, the query/mutation
            //   will no-op safely (caught and logged).
            if (!isPR) {
              const title = payload.issue?.title ?? "";
              const lower = title.toLowerCase();

              let desiredTypeName = null;
              if (lower.startsWith("bug -")) desiredTypeName = "Bug";
              else if (lower.startsWith("feature -")) desiredTypeName = "Feature";
              else if (lower.startsWith("chore -")) desiredTypeName = "Chore";

              if (desiredTypeName) {
                try {
                  const query = `
                    query($owner: String!, $repo: String!, $number: Int!) {
                      repository(owner: $owner, name: $repo) {
                        issue(number: $number) {
                          id
                          issueType { id name }
                        }
                        issueTypes(first: 50) {
                          nodes { id name }
                        }
                      }
                    }
                  `;

                  const res = await github.graphql(query, { owner, repo, number: issue_number });
                  const repoInfo = res?.repository;
                  const issue = repoInfo?.issue;
                  const types = repoInfo?.issueTypes?.nodes ?? [];

                  const currentTypeName = issue?.issueType?.name ?? null;
                  if (currentTypeName === desiredTypeName) return;

                  const desiredType = types.find((t) => t?.name === desiredTypeName);
                  if (!issue?.id || !desiredType?.id) {
                    console.log("Issue type sync skipped: missing issue id or issueType id", {
                      issueId: issue?.id,
                      desiredTypeName,
                      availableTypes: types.map((t) => t?.name),
                    });
                    return;
                  }

                  const mutation = `
                    mutation($issueId: ID!, $issueTypeId: ID!) {
                      updateIssue(input: { id: $issueId, issueTypeId: $issueTypeId }) {
                        issue { id issueType { name } }
                      }
                    }
                  `;

                  await github.graphql(mutation, { issueId: issue.id, issueTypeId: desiredType.id });
                } catch (e) {
                  // We don't want labeling to fail just because issue types aren't available/configured.
                  console.log("Issue type sync failed (non-fatal):", e?.message ?? e);
                }
              }
            }


