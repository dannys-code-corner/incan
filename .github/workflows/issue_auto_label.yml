name: Auto-label issues and PRs (sync)

on:
  issues:
    types: [opened, edited]
  # pull_request:
  #   types: [opened, edited, reopened, synchronize, ready_for_review]
  pull_request_target:
    types: [opened, edited, reopened, synchronize, ready_for_review]

permissions:
  issues: write

jobs:
  label:
    runs-on: ubuntu-latest
    steps:
      - name: Dump event payload (debug)
        run: cat "$GITHUB_EVENT_PATH"

      - name: GitHub App installation token
        id: app_token
        env:
          APP_ID: ${{ secrets.INCAN_TRIAGE_APP_ID }}
          INSTALLATION_ID: ${{ secrets.INCAN_TRIAGE_APP_INSTALLATION_ID }}
          PRIVATE_KEY: ${{ secrets.INCAN_TRIAGE_APP_PRIVATE_KEY }}
        run: |
          # enable strict error handling
          set -euo pipefail

          # base64 URL encoding
          b64url() { openssl base64 -A | tr '+/' '-_' | tr -d '='; }

          # generate JWT
          now=$(date +%s)
          header='{"alg":"RS256","typ":"JWT"}'
          payload=$(printf '{"iat":%d,"exp":%d,"iss":"%s"}' "$((now-60))" "$((now+540))" "$APP_ID")

          # base64 URL encode the header and payload
          header_b64=$(printf '%s' "$header" | b64url)
          payload_b64=$(printf '%s' "$payload" | b64url)
          unsigned="$header_b64.$payload_b64"

          # sign the JWT
          keyfile=$(mktemp)
          printf '%s\n' "$PRIVATE_KEY" > "$keyfile"
          sig=$(printf '%s' "$unsigned" | openssl dgst -sha256 -sign "$keyfile" | b64url)
          rm -f "$keyfile"
          jwt="$unsigned.$sig"

          # get the installation token
          token=$(curl -sS -X POST \
            -H "Authorization: Bearer $jwt" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens" \
            | jq -r '.token')

          echo "token=$token" >> "$GITHUB_OUTPUT"
      
      - uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app_token.outputs.token }}
          script: |
            const isPR = context.eventName === "pull_request_target";
            const payload = context.payload;
            const body = isPR ? (payload.pull_request?.body ?? "") : (payload.issue?.body ?? "");

            // Only manage these labels; never remove unrelated labels (bug/feature/etc).
            const managed = new Set([
              "incan language semantics",
              "incan compiler",
              "tooling",
              "editor integration",
              "runtime / core crates",
              "documentation",
            ]);

            // Map template "Area" option strings -> labels.
            // IMPORTANT: these option strings must match the templates exactly.
            const optionToLabel = new Map([
              ["Incan Language (syntax/semantics)", "incan language semantics"],
              ["Compiler (frontend/backend/codegen)", "incan compiler"],
              ["Tooling (CLI/formatter/test runner)", "tooling"],
              ["Editor integration (LSP/VS Code extension)", "editor integration"],
              ["Runtime / Core crates (stdlib/core/derive)", "runtime / core crates"],
              ["Documentation", "documentation"],
            ]);

            // Extract a section from a markdown string based on a heading.
            function extractSection(markdown, heading) {
              // Escape special regex characters in the heading.
              const esc = heading.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
              // Create a regular expression to match the heading.
              const re = new RegExp(`^\\s*#{2,6}\\s+${esc}\\s*$`, "mi");
              // Execute the regular expression on the markdown string.
              const m = re.exec(markdown);
              // If no match, return an empty string.
              if (!m) return "";
              // Get the start index of the match.
              const start = m.index + m[0].length;
              // Get the rest of the markdown string after the match.
              const rest = markdown.slice(start);
              const next = rest.search(/^\\s*#{2,6}\\s+/m);
              return (next === -1 ? rest : rest.slice(0, next)).trim();
            }

            // Issue forms render the dropdown under "### Area"; PR template uses "## Area(s)".
            let areaBlock = extractSection(body, isPR ? "Area(s)" : "Area");
            if (!areaBlock) {
              areaBlock = extractSection(body, "Area");
            }

            const desired = new Set();

            if (isPR) {
              // PR template uses checkboxes; only apply labels for checked items.
              const checkedLines = areaBlock
                .split("\n")
                .map((l) => l.trim())
                .filter((l) => /^[-*]\s*\[[xX]\]\s+/.test(l));

              // For each option, add the corresponding label to the set.
              for (const [opt, label] of optionToLabel.entries()) {
                if (checkedLines.some((l) => l.includes(opt))) desired.add(label);
              }

              // Log the preview of the area block, the checked lines, and the desired labels.
              console.log({ isPR, areaBlockPreview: areaBlock.slice(0, 300), checkedLines, desired: [...desired] });
            } else {
              // Issue forms render selected options as plain text in the section.
              for (const [opt, label] of optionToLabel.entries()) {
                if (areaBlock.includes(opt)) desired.add(label);
              }
            }

            // If user picked "Other" or the section is missing, don't touch labels.
            if (desired.size === 0) return;

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = isPR ? payload.pull_request.number : context.issue.number;

            // Current labels on the issue/PR
            const current = new Set(
              (isPR ? payload.pull_request.labels : payload.issue.labels ?? []).map((l) => l.name)
            );

            // Compute label changes
            const toAdd = [...desired].filter(l => !current.has(l));
            const toRemove = [...current].filter(l => managed.has(l) && !desired.has(l));

            if (toAdd.length > 0) {
              await github.rest.issues.addLabels({ owner, repo, issue_number, labels: toAdd });
            }

            for (const label of toRemove) {
              try {
                await github.rest.issues.removeLabel({ owner, repo, issue_number, name: label });
              } catch (e) {
                // If the label was removed concurrently or doesn't exist, ignore.
                if (e?.status !== 404) throw e;
              }
            }


